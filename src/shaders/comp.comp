#version 460

#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_spirv_intrinsics : enable
#extension GL_GOOGLE_include_directive : enable


#extension GL_EXT_nonuniform_qualifier : require


#define M_PI 3.14159265f

#define WORKGROUP_SIZE 16
layout(local_size_x = 4, local_size_y = 4, local_size_z = 1) in;

struct Pixel
{
    vec4 value;
};
/*
layout(std140, binding = 0) buffer buf
{
    Pixel image[];
};
*/
layout(set = 0, binding = 0, rgba32f) uniform image2D buf;
layout(std140, push_constant ) uniform UniformBufferObject
{
    float width;
    float height;
    uint t;

    vec4 camera_pos;
    vec4 camera_target;
    vec4 camera_up;

    float aperture;
    float focus_disk;

    uint bounce_limit;
    uint scale;

    uint use_fsr;
    int mesh_index;
    int material_index;
} ubo;

//#define SHOW_DEPTH
#include "hittable/hittable.comp"
#include "hittable/meshes.comp"
#include "utils/camera.comp"
#include "utils/random.comp"
#include "utils/ray.comp"
#include "utils/vec.comp"

bool is_v_invalid(float value)
{
    return isnan(value) || isinf(value);
}
void main()
{
    const float window_width = (ubo.width) / int(ubo.scale);
    const float window_height = (ubo.height) / int(ubo.scale);
    const uint x = gl_GlobalInvocationID.x;
    const uint y = gl_GlobalInvocationID.y;
    const vec2 cc = vec2(x / window_width , y / window_height );
    random_init(cc);
    camera cam = camera_init(ubo.camera_pos.xyz, vec3(ubo.camera_target.xyz), vec3(0, 1, 0), 0, 9.3, window_width / window_height);

    vec4 prev = vec4(0);
    if (ubo.t >= float(1))
    {

 //   memoryBarrierImage();
        prev = imageLoad(buf, ivec2(x, y));
    
    }

    vec2 rpos = vec2((x) / window_width, 1 - ((y - 1) / window_height));

    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);

    float u = ((float(x) + random()) / (window_width - 1));
    float v = ((float(y) + random()) / (window_height - 1));


    Ray r = camera_ray(cam, u, v);
    r.inv_direction = vec3(1) / r.direction;
    color = ray_color(r, u, v, ubo.bounce_limit);

    if(is_v_invalid(color.x) || is_v_invalid(color.y) || is_v_invalid(color.z))
    {
        color = vec4(0);
    }

//    memoryBarrierImage();

    imageStore(buf, ivec2(x, y), ((prev * (ubo.t)) + (color)) / ((ubo.t + 1)));
}