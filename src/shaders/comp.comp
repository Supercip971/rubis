#version 450 core

#extension GL_ARB_gpu_shader5 : require 
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_spirv_intrinsics : enable
#extension GL_GOOGLE_include_directive : enable

#define M_PI 3.14159265f

#define WORKGROUP_SIZE 16
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

struct Pixel
{
    vec4 value;
};
/*
layout(std140, binding = 0) buffer buf
{
    Pixel image[];
};
*/
layout(binding = 0, rgba32f) uniform image2D buf;

layout(std140, binding = 1) readonly uniform UniformBufferObject
{
    float width;
    float height;
    uint t;
    vec4 camera_pos;

    vec4 camera_target;
    vec4 camera_up;
    float aperture;
    float focus_disk;
}
ubo;

//#define SHOW_DEPTH
#include "hittable/hittable.comp"
#include "hittable/meshes.comp"
#include "utils/camera.comp"
#include "utils/random.comp"
#include "utils/ray.comp"
#include "utils/vec.comp"

void main()
{
    const float window_width = (ubo.width);
    const float window_height = (ubo.height);
    const uint x = gl_GlobalInvocationID.x;
    const uint y = gl_GlobalInvocationID.y;
    const vec2 cc = vec2(x / window_width , y / window_height );
    random_init(cc);
    camera cam = camera_init(ubo.camera_pos.xyz, vec3(ubo.camera_target.xyz), vec3(0, 1, 0), 0, 9.3);

    vec4 prev = vec4(0);
    if (ubo.t >= float(2))
    {
        prev = imageLoad(buf, ivec2(x, y));
    }

    vec2 rpos = vec2((x) / window_width, 1 - ((y - 1) / window_height));

    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);

    float u = ((float(x) + random()) / (window_width - 1));
    float v = ((float(y) + random()) / (window_height - 1));

    Ray r = camera_ray(cam, u, v);
    r.inv_direction = vec3(1) / r.direction;
    color = ray_color(r, u, v, 4);

    imageStore(buf, ivec2(x, y), ((prev * (ubo.t)) + color) / ((ubo.t + 1)));
}