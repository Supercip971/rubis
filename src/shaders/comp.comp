#version 460 core

#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_spirv_intrinsics : enable
#extension GL_GOOGLE_include_directive : enable

#extension GL_EXT_nonuniform_qualifier : require


#extension GL_EXT_ray_query : require
#define M_PI 3.14159265f

#define WORKGROUP_SIZE 16
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

struct Pixel
{
    vec4 value;
};
/*
layout(std140, binding = 0) buffer buf
{
    Pixel image[];
};
*/
layout(set = 0, binding = 0, rgba32f) uniform image2D buf;
layout(std140, push_constant) uniform UniformBufferObject
{
    float width;
    float height;
    uint t;

    vec4 camera_pos;
    vec4 camera_target;
    vec4 camera_up;

    float aperture;
    float focus_disk;

    uint bounce_limit;
    uint scale;

    uint use_fsr;
    int mesh_index;
    int material_index;
    float fov;
}
ubo;

struct raytraceInfo
{
    vec4 albedo;
    vec4 normal;
    vec4 position;
};
layout(set =0, binding = 9, std140) writeonly buffer info {
    raytraceInfo infos[];
};
// #define SHOW_DEPTH
#include "hittable/hittable.comp"
#include "hittable/meshes.comp"
#include "utils/camera.comp"
#include "utils/random.comp"
#include "utils/ray.comp"
#include "utils/vec.comp"

bool is_v_invalid(float value)
{
    return isnan(value) || isinf(value);
}
void main()
{
    const float window_width = (ubo.width) / int(ubo.scale);
    const float window_height = (ubo.height) / int(ubo.scale);
    const uint x = gl_GlobalInvocationID.x;
    const uint y = gl_GlobalInvocationID.y;
    const vec2 cc = vec2(x / window_width , y / window_height);
    random_init(vec2(gl_WorkGroupID.x, gl_WorkGroupID.y));
    camera cam = camera_init(ubo.camera_pos.xyz, vec3(ubo.camera_target.xyz), vec3(0, 1, 0), 0, 9.3, window_width / window_height);

    vec2 rpos = vec2((x) / window_width, 1 - ((y - 1) / window_height));
    ExportRecord er;
    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);
    int count = 0;
    for(int cu = 0; cu < 1; cu++)
    {
        float u = ((float(x) + random()) / (window_width - 1));
        float v = ((float(y) + random()) / (window_height - 1));

        Ray r = camera_ray(cam, u, v);
        r.inv_direction = vec3(1) / r.direction;
        
        vec4 prev = color;;
        color += (ray_color(r, u, v, ubo.bounce_limit, er));

        if (is_v_invalid(color.x) || is_v_invalid(color.y) || is_v_invalid(color.z))
        {
            color = prev;
        }
        count ++;
      //  color = vec4(er.albedo, 1.0);
    }
    //memoryBarrierImage();
    vec4 prev = vec4(0);
    if (ubo.t > float(0))
    {

        //   memoryBarrierImage();
        prev = imageLoad(buf, ivec2(x, y));
    }
   // if(ubo.t <= 1) 
   // {
   //     int pos = int(x) + int(y * ubo.width);
   //     infos[pos].albedo = vec4(er.albedo, 0.0);
   //     infos[pos].normal = vec4(er.normal, 0.0);
   //     infos[pos].position = vec4(er.pos, 0.0);
   // }
    imageStore(buf, ivec2(x, y), ((prev * (ubo.t)) + (color)) / ((ubo.t + count)));
}