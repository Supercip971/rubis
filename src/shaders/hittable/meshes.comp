#ifndef MESHES_COMP
#define MESHES_COMP

#include "hittable/bvh.comp"
#include "hittable/hittable.comp"
#include "hittable/material.comp"
#include "utils/ray.comp"

// #define SHOW_BVH

layout(std140, binding = 2) readonly buffer MeshesBufData
{
    vec4 buf_datas[];
};

struct Mesh
{
    uint type;
    uint material_type;
    uint material_data_start;
    uint material_data_end;
    uint mesh_data_start;
    uint mesh_data_end;
    vec4 aabb1;
    vec4 aabb2;
};

layout(std140, binding = 3) readonly buffer MeshesBuf
{
    Mesh meshes[];
};

layout(std140, binding = 5) readonly buffer BvhBuf
{
    Bvh bvhs[];
};
layout(binding = 6) uniform sampler2DArray textures;
layout(binding = 7) uniform sampler2D skymap;

#define FROM_SIBLING 1
#define FROM_PARENT 2
#define FROM_CHILD 3

HittableRecord process_leaf(Ray r, int id, float cmin, float cmax)
{
    Mesh current_mesh = meshes[id];

    vec3 pa = buf_datas[current_mesh.mesh_data_start].xyz;
    vec3 pb = buf_datas[current_mesh.mesh_data_start + 1].xyz;
    vec3 pc = buf_datas[current_mesh.mesh_data_start + 2].xyz;

    HittableRecord res = hit_triangle(cmin, cmax, r, pa, pb, pc);

    res.mesh_id = id;

    return res;
}

bool aabb_hit(Ray r, Bvh cur, float t_min, float t_max)
{
    const vec3 invd = (r.inv_direction);
    vec3 t0 = ((cur.aabb_min.xyz - r.origin) * invd);
    vec3 t1 = ((cur.aabb_max.xyz - r.origin) * invd);
    if (invd.x < 0.0f)
    {
        // if(dir.x < 0)
        // swap(t0.x, t1.x);
        float _temp = t0.x;
        t0.x = t1.x;
        t1.x = _temp;
    }
    if (invd.y < 0.0f)
    {
        //  if(dir.y < 0)
        // swap(t0.y, t1.y);
        float _temp = t0.y;
        t0.y = t1.y;
        t1.y = _temp;
    }
    if (invd.z < 0.0f)
    {
        // if(dir.z < 0)
        // swap(t0.z, t1.z);
        float _temp = t0.z;
        t0.z = t1.z;
        t1.z = _temp;
    }
    t_min = max(t0.y, t_min);
    t_min = max(t0.z, t_min);
    t_min = max(t0.x, t_min);

    t_max = min(t1.x, t_max);
    t_max = min(t1.z, t_max);
    t_max = min(t1.y, t_max);
    if (t_max < t_min)
    {
        return false;
    }

    return true;
}
bool aabb_hit2(Ray r, Bvh cur, float t_min, float t_max)
{

    vec3 inv_dir = vec3(1) / r.direction;
    vec3 t0 = ((cur.aabb_min.xyz - r.origin) / r.direction);
    vec3 t1 = ((cur.aabb_max.xyz - r.origin) / r.direction);
    vec3 tmax = max(t0, t1);
    vec3 tmin = min(t0, t1);

    return vec3_min_comp(tmax) >= vec3_max_comp(tmin);
}

#define STACK_SIZE 32

HittableRecord traverse_bvh_stack(Ray r, float cmin_f, float cmax_f)
{
    int stack[STACK_SIZE];

    int current = bvhs[0].l;
    float cmin = cmin_f;
    float cmax = cmax_f;
    int i = 0;
    int sp = 0;
    stack[sp] = 0;
    sp++;
    HittableRecord res;
    res.hitted = false;

    while (sp > 0 && sp < STACK_SIZE)
    {
        sp--; // pop

        Bvh cur = bvhs[stack[sp]];
        if (cur.is_next_a_bvh == 0)
        {
            HittableRecord rec2 = process_leaf(r, cur.l, cmin, cmax);
            if (rec2.hitted)
            {
                cmax = rec2.t;
                res = rec2;
            }
            if (cur.r != 0)
            {
                rec2 = process_leaf(r, cur.r, cmin, cmax);
                if (rec2.hitted)
                {
                    cmax = rec2.t;
                    res = rec2;
                }
            }
        }
        else
        {
            Bvh lb = bvhs[cur.l];
            Bvh rb = bvhs[cur.r];

            if (aabb_hit(r, lb, cmin, cmax))
            {
                stack[sp] = cur.l;

                sp++;
            }
            if (aabb_hit(r, rb, cmin, cmax))
            {

                stack[sp] = cur.r;

                sp++;
            }
        }
    }
    return res;
}

MaterialRecord material_hit(HittableRecord record, Ray r)
{
    Mesh current_mesh = meshes[record.mesh_id];
    MaterialRecord result;
    result.emitted = vec3(0, 0, 0);
    vec4 first = buf_datas[current_mesh.material_data_start].xyzw;
    /*
    if ((current_mesh.material_type & 1) != 0)
    {
        result.attenuation = first;
        result.scatter = Ray(record.point, vec3_random_unit() + record.normal, vec3(1));

        if (is_vec_near_zero(result.scatter.direction))
        {
            result.scatter.direction = record.normal;
        }

        result.do_scatter = true;
    }
    else if ((current_mesh.material_type & 2) != 0)
    {
        float fuzz = buf_datas[current_mesh.material_data_start + 1].x;
        result.attenuation = first;
        result.scatter = Ray(record.point, reflect(vec_unit(r.direction), record.normal) + vec3_random_unit() * fuzz, vec3(0));

        result.do_scatter = dot(result.scatter.direction, record.normal) > 0.0f;
    }
    else if ((current_mesh.material_type & 4) != 0)
    {
        float idx = first.x;
        vec3 attenuation = vec3(1);
        float refract_ratio = record.front ? (1.0 / idx) : idx;

        vec3 unit_direction = vec_unit(r.direction);

        float cos_theta = min(dot(-unit_direction, record.normal), 1.0);
        float sin_theta = sqrt(1.0 - cos_theta * cos_theta);

        bool cannot_refract = refract_ratio * sin_theta > 1.0;

        vec3 dir;
        if (cannot_refract || reflectance(cos_theta, refract_ratio) > random())
        {
            dir = reflect(unit_direction, record.normal);
        }
        else
        {
            dir = refract(unit_direction, record.normal, refract_ratio);
        }
        result.attenuation = attenuation;
        result.scatter = Ray(record.point, dir, vec3(1) / dir);
        result.do_scatter = true;
    }

    else if ((current_mesh.material_type & 8) != 0)
    {

        result.emitted = first;
        result.do_scatter = false;
    }*/

    int base = int(first.y);

    int metal = int(first.z);
    int normal = int(first.x);

    int emitid = int(first.w);

    vec3 emit = buf_datas[current_mesh.material_data_start + 3].xyz;

    if (emitid >= 0)
    {
        emit *= texture(textures, vec3(record.uv, emitid)).xyz;
    }



    vec3 fact = buf_datas[current_mesh.material_data_start + 2].xyz;

    if (normal >= 0)
    {
        vec3 normalv = texture(textures, vec3(record.uv * fact.z, normal)).xyz;
        normalv = (normalv * 2 - vec3(1));
        record.normal = normalize(record.normal * (normalv));
    }

    //  result.emitted = vec3(record.uv, 1.0 - (record.uv.x + record.uv.y));
    // result.emitted = texture(textures, vec3(record.uv, base)).xyz;

    float alpha = 1;
    if (base < 0)
    {
        result.attenuation = buf_datas[current_mesh.material_data_start + 1].xyz;
        alpha = buf_datas[current_mesh.material_data_start + 1].w;
    }
    else
    {
        result.attenuation = texture(textures, vec3(record.uv, base)).xyz;
        alpha = texture(textures, vec3(record.uv, base)).w;
    }


    vec3 metal_roughness = vec3(1, 1, 1);
    if (metal >= 0)
    {
        metal_roughness = texture(textures, vec3(record.uv, metal)).xyz;
    }
    metal_roughness.z *= fact.x;

    metal_roughness.y *= fact.y;

    metal_roughness.z = metal_roughness.z;

    metal_roughness.y = metal_roughness.y;

    //  result.attenuation = fact;
    //  result.attenuation = mix(vec3(1), result.attenuation, 1);
    // result.do_scatter = false;
    //    result.scatter = Ray(record.point, reflect(r.direction, record.normal), vec3(1));

    result.emitted = emit;

    // y = metal
    // z = roughness

    result.emitted += result.attenuation;
    vec3 dir;
    {
        float idx = 1.5;

        float refract_ratio = 1.0 / idx;
        if (!record.front)
        {
            refract_ratio = idx;
        }

        vec3 unit_direction = vec_unit(r.direction);

        vec3 normalv = vec_unit(record.normal + vec3_random_unit() * metal_roughness.y);
        vec3 normalg = vec_unit(record.normal + vec3_random_unit());

        float cos_theta = min(abs(dot(-unit_direction, record.normal)), 1.0);
        //  float sin_theta = sqrt(1.0 - cos_theta * cos_theta);

        //  bool cannot_refract = (refract_ratio * sin_theta) > 1.001;

        if (reflectance(cos_theta, refract_ratio) > (random()))
        {

            dir = reflect(unit_direction, normalv);
        }
        else
        {
            // 0.04 + (1 - 0.04) * (1 - abs(VdotH))^5
            //   result.attenuation = mix(result.attenuation, result.attenuation * (1 / M_PI), 0.04 + (1 - 0.04) * pow(1 - abs(cos_theta), 5));

            dir = reflect(unit_direction, normalv);
        }

        //   result.attenuation.y = metal_roughness.y; // smooth
        //   result.attenuation.z = metal_roughness.z; // metal
        //   result.attenuation.x = 0;
        if (random() > (metal_roughness.z))
        {
            dir = vec_unit(reflect(unit_direction, record.normal) + vec3_random_unit());
        }

        // result.attenuation = result.emitted;
    }

    result.scatter = Ray(record.point, dir, vec3(1));
    if(random() > (alpha))
    {
        result.attenuation = vec3(1);
        result.scatter.direction = vec3(r.direction);
    }

    result.scatter.inv_direction = vec3(1) / result.scatter.direction;

    result.do_scatter = length(emit) < 1.02;

    // result.attenuation.x = result.scatter_factor;
    // result.emitted.x = result.scatter_factor;
    // if (record.front)
    //{
    //     result.attenuation = vec3(1, 0, 0);
    //     result.emitted = result.attenuation;
    //     result.do_scatter = false;
    // }
    return result;
}
HittableRecord world_hit(Ray r, float x, float y)
{

    float cmin = 0.000001f;
    float cmax = 1000000.f;

    HittableRecord rec = traverse_bvh_stack(r, cmin, cmax);
    if (rec.hitted)
    {
        Mesh current_mesh = meshes[rec.mesh_id];

        vec3 pa = buf_datas[current_mesh.mesh_data_start].xyz;
        vec3 pb = buf_datas[current_mesh.mesh_data_start + 1].xyz;
        vec3 pc = buf_datas[current_mesh.mesh_data_start + 2].xyz;
        vec2 uva = buf_datas[current_mesh.mesh_data_start + 3].xy;
        vec2 uvb = vec2(buf_datas[current_mesh.mesh_data_start + 3].z, buf_datas[current_mesh.mesh_data_start + 4].x);
        vec2 uvc = buf_datas[current_mesh.mesh_data_start + 4].yz;
        vec3 na = buf_datas[current_mesh.mesh_data_start + 5].xyz;
        vec3 nb = buf_datas[current_mesh.mesh_data_start + 6].xyz;
        vec3 nc = buf_datas[current_mesh.mesh_data_start + 7].xyz;

        vec3 edge_1 = pb - pa;
        vec3 edge_2 = pc - pa;

        rec.normal = na * (1 - rec.uv.x - rec.uv.y) + nb * (rec.uv.x) + nc * (rec.uv.y);
        vec2 final = uva * (1 - rec.uv.x - rec.uv.y) + uvb * (rec.uv.x) + uvc * (rec.uv.y);
        rec.uv = final;

        rec = update_face_normal(rec, r, rec.normal);
    }

    return rec;
}

vec4 sky_color(Ray r)
{

    vec3 unit_direction = vec_unit(r.direction);
    // float t = (unit_direction.y + 1.0f) * 0.5f;
    float t = acos(unit_direction.y);
    float p = atan(-unit_direction.z, unit_direction.x) + 3.1415;
    float u = p * (1 / (2 * 3.1415));
    float v = t * (1 / 3.1415);

    vec3 rc = texture(skymap, vec2(u, v)).rgb;
    if (length(rc) > 0.9)
    {
        //      return vec4((rc * 2) * (rc * 2), 1);
    }
    return vec4(rc, 1);
    //  return (1.0 - t) * vec4(1.0) + t * vec4(0.5, 0.7, 1.0, 1.0);
    //  return vec4(1, 0, 0, 0);
}
vec4 ray_color(Ray r, float x, float y, int maxv)
{

    HittableRecord rec = world_hit(r, x, y);
    vec4 result = vec4(1);

    int depth = 0;

#ifdef SHOW_BVH
    return vec4(float(rec.tcount), float(rec.tcount) / 256, float(rec.tcount) / 512, 1);
#endif
    if (!rec.hitted)
    {

        return sky_color(r);
    }

    while (true)
    {
        MaterialRecord material = material_hit(rec, r);

        
        /*
            MaterialRecord material;
            material.do_scatter = false;
            */

        if (material.do_scatter)
        {
            r = material.scatter;

            result = result * vec4(material.attenuation, 1.0);
        }
        else
        {
            // result = result * mix(vec4(1), vec4(material.emitted, 1.0), sfact);
            result = result * (vec4(material.emitted, 1.0));

            return result;
        }

        rec = world_hit(r, x, y);
        depth += 1;
        if (rec.hitted == false || depth > maxv)
        {
            result = result * sky_color(r);

            return vec4(result);
        }
    }
}

#endif