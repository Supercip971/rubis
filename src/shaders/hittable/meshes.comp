#ifndef MESHES_COMP
#define MESHES_COMP

#include "hittable/bvh.comp"
#include "hittable/hittable.comp"
#include "hittable/material.comp"
#include "utils/color.comp"
#include "utils/ray.comp"

// #define SHOW_BVH

layout(std140, binding = 2) readonly buffer MeshesBufData
{
    vec4 buf_datas[];
};

struct Mesh
{
    uint type;
    uint material_type;
    uint material_data_start;
    uint material_data_end;
    uint mesh_data_start;
    uint mesh_data_end;
    vec4 aabb1;
    vec4 aabb2;
};

layout(std140, binding = 3) readonly buffer MeshesBuf
{
    Mesh meshes[];
};

layout(std140, binding = 5) readonly buffer BvhBuf
{
    Bvh bvhs[];
};
layout(binding = 6) uniform sampler2DArray textures;
layout(binding = 7) uniform sampler2D skymap;

#define FROM_SIBLING 1
#define FROM_PARENT 2
#define FROM_CHILD 3

HittableRecord process_leaf(Ray r, int id, float cmin, float cmax)
{
    Mesh current_mesh = meshes[id];

    vec3 pa = buf_datas[current_mesh.mesh_data_start].xyz;
    vec3 pb = buf_datas[current_mesh.mesh_data_start + 1].xyz;
    vec3 pc = buf_datas[current_mesh.mesh_data_start + 2].xyz;

    HittableRecord res = hit_triangle(cmin, cmax, r, pa, pb, pc);

    res.mesh_id = id;

    return res;
}

bool aabb_hit(Ray r, Bvh cur, float t_min, float t_max)
{
    const vec3 invd = (r.inv_direction);
    vec3 t0 = ((cur.aabb_min.xyz - r.origin) * invd);
    vec3 t1 = ((cur.aabb_max.xyz - r.origin) * invd);
    if (invd.x < 0.0f)
    {
        // if(dir.x < 0)
        // swap(t0.x, t1.x);
        float _temp = t0.x;
        t0.x = t1.x;
        t1.x = _temp;
    }
    if (invd.y < 0.0f)
    {
        //  if(dir.y < 0)
        // swap(t0.y, t1.y);
        float _temp = t0.y;
        t0.y = t1.y;
        t1.y = _temp;
    }
    if (invd.z < 0.0f)
    {
        // if(dir.z < 0)
        // swap(t0.z, t1.z);
        float _temp = t0.z;
        t0.z = t1.z;
        t1.z = _temp;
    }
    t_min = max(t0.y, t_min);
    t_min = max(t0.z, t_min);
    t_min = max(t0.x, t_min);

    t_max = min(t1.x, t_max);
    t_max = min(t1.z, t_max);
    t_max = min(t1.y, t_max);
    if (t_max < t_min)
    {
        return false;
    }

    return true;
}
bool aabb_hit2(Ray r, Bvh cur, float t_min, float t_max)
{

    vec3 inv_dir = vec3(1) / r.direction;
    vec3 t0 = ((cur.aabb_min.xyz - r.origin) / r.direction);
    vec3 t1 = ((cur.aabb_max.xyz - r.origin) / r.direction);
    vec3 tmax = max(t0, t1);
    vec3 tmin = min(t0, t1);

    return vec3_min_comp(tmax) >= vec3_max_comp(tmin);
}

#define STACK_SIZE 32

HittableRecord traverse_bvh_stack(Ray r, float cmin_f, float cmax_f)
{
    int stack[STACK_SIZE];

    int current = bvhs[0].l;
    float cmin = cmin_f;
    float cmax = cmax_f;
    int i = 0;
    int sp = 0;
    stack[sp] = 0;
    sp++;
    HittableRecord res;
    res.hitted = false;

    while (sp > 0 && sp < STACK_SIZE)
    {
        sp--; // pop

        Bvh cur = bvhs[stack[sp]];
        if (cur.is_next_a_bvh == 0)
        {
            HittableRecord rec2 = process_leaf(r, cur.l, cmin, cmax);
            if (rec2.hitted)
            {
                cmax = rec2.t;
                res = rec2;
            }
            if (cur.r != 0)
            {
                rec2 = process_leaf(r, cur.r, cmin, cmax);
                if (rec2.hitted)
                {
                    cmax = rec2.t;
                    res = rec2;
                }
            }
        }
        else
        {
            Bvh lb = bvhs[cur.l];
            Bvh rb = bvhs[cur.r];

            if (aabb_hit(r, lb, cmin, cmax))
            {
                stack[sp] = cur.l;

                sp++;
            }
            if (aabb_hit(r, rb, cmin, cmax))
            {

                stack[sp] = cur.r;

                sp++;
            }
        }
    }
    return res;
}

MaterialRecord material_hit(HittableRecord record, Ray r)
{
    Mesh current_mesh = meshes[record.mesh_id];
    MaterialRecord result;
    result.emitted = vec3(0, 0, 0);
    vec4 first = buf_datas[current_mesh.material_data_start].xyzw;
  

    int base = int(first.y);

    int metal = int(first.z);
    int normal = int(first.x);

    int emitid = int(first.w);

    vec3 emit = buf_datas[current_mesh.material_data_start + 3].xyz;

    if (emitid >= 0)
    {
        emit *= texture(textures, vec3(record.uv, emitid)).xyz;
    }

    vec3 fact = buf_datas[current_mesh.material_data_start + 2].xyz;

    float alpha = 1;
    if (base < 0)
    {
        result.attenuation = buf_datas[current_mesh.material_data_start + 1].xyz;
        alpha = buf_datas[current_mesh.material_data_start + 1].w;
    }
    else
    {
        result.attenuation = srgb_to_linear(texture(textures, vec3(record.uv, base)).xyz);
        alpha = 1.0;

        //        alpha = texture(textures, vec3(record.uv, base)).w;
    }

    if (normal >= 0)
    {

        vec3 normalv = vec3(1);
        vec3 T = normalize((record.tangent));
        vec3 N = normalize((record.normal));
        vec3 B = normalize(record.bittangent);

        normalv = texture(textures, vec3((record.uv), int(normal))).rgb * 2.0 - vec3(1.0);
        normalv = normalize(normalv);

        if (dot(r.direction, record.normal) > 0.0f)
        {
            N = -N;
            T = -T;
            B = -B;
        }

        mat3 TBN = (mat3(T, B, N));

        record.normal = normalize(((normalv * TBN)));
    }

    vec3 metal_roughness = vec3(1, 1, 1);
    if (metal >= 0)
    {
        metal_roughness = texture(textures, vec3(record.uv, metal)).xyz;
    }
    metal_roughness.z *= fact.x;

    metal_roughness.y *= fact.y;

    metal_roughness.z = metal_roughness.z;

    metal_roughness.y = metal_roughness.y;

    result.emitted = emit;

    // y = roughtness
    // z = metalness

    result.emitted += result.attenuation;

    vec3 dir;
    {
        const float idx = 1.5;

        float refract_ratio = 1.0 / idx;
        if (!record.front)
        {
            refract_ratio = idx;
        }

        vec3 unit_direction = vec_unit(r.direction);

        vec3 normalv = vec_unit(record.normal + random_in_hemisphere(record.normal) * clamp(metal_roughness.y, 0, 1) * (random() + 0.5));

        float cos_theta = min(abs(dot(-unit_direction, normalv)), 1.0);

        if (reflectance(cos_theta, refract_ratio) > (random()))
        {

            dir = reflect(unit_direction, normalv);
            vec3 f0 = mix(vec3((idx - 1) / (idx + 1)), result.attenuation, metal_roughness.z);
            result.attenuation = f0;
        }
        else
        {
            dir = reflect(unit_direction, normalv);

            if (random() > (metal_roughness.z))
            {
                dir = vec_unit(reflect(unit_direction, random_in_hemisphere(record.normal)));
            }
        }
    }

    dir = vec_unit(dir);

    result.scatter = Ray(record.point, dir, vec3(1));

    if (random() > (alpha))
    {
        result.attenuation = vec3(1, 1, 1);
        result.scatter.direction = vec3(r.direction);
    }

    result.scatter.inv_direction = vec3(1) / result.scatter.direction;

    result.do_scatter = length(emit) < 1.02;

    return result;
}

HittableRecord world_hit(Ray r, float x, float y)
{

    float cmin = 0.000001f;
    float cmax = 1000000.f;

    HittableRecord rec = traverse_bvh_stack(r, cmin, cmax);
    if (rec.hitted)
    {
        Mesh current_mesh = meshes[rec.mesh_id];

        vec3 pa = buf_datas[current_mesh.mesh_data_start].xyz;
        vec3 pb = buf_datas[current_mesh.mesh_data_start + 1].xyz;
        vec3 pc = buf_datas[current_mesh.mesh_data_start + 2].xyz;
        vec2 uva = buf_datas[current_mesh.mesh_data_start + 3].xy;
        vec2 uvb = vec2(buf_datas[current_mesh.mesh_data_start + 3].z, buf_datas[current_mesh.mesh_data_start + 4].x);
        vec2 uvc = buf_datas[current_mesh.mesh_data_start + 4].yz;
        vec3 na = buf_datas[current_mesh.mesh_data_start + 5].xyz;
        vec3 nb = buf_datas[current_mesh.mesh_data_start + 6].xyz;
        vec3 nc = buf_datas[current_mesh.mesh_data_start + 7].xyz;
        vec3 ta = buf_datas[current_mesh.mesh_data_start + 8].xyz;
        vec3 tb = buf_datas[current_mesh.mesh_data_start + 9].xyz;
        vec3 tc = buf_datas[current_mesh.mesh_data_start + 10].xyz;

        vec3 edge_1 = pb - pa;
        vec3 edge_2 = pc - pa;

        //     rec.normal = (normalize(cross(edge_1, edge_2)));
        rec.normal = normalize((na * (1 - rec.uv.x - rec.uv.y) + nb * (rec.uv.x) + nc * (rec.uv.y)));
        rec.tangent = normalize((ta * (1 - rec.uv.x - rec.uv.y) + tb * (rec.uv.x) + tc * (rec.uv.y)));
        rec.tangent_sign = buf_datas[current_mesh.mesh_data_start + 8].w;
        vec2 final = (uva * (1.0 - rec.uv.x - rec.uv.y) + uvb * (rec.uv.x) + uvc * (rec.uv.y));
        rec.uv = final;

       rec.bittangent = rec.tangent_sign * cross(rec.normal, rec.tangent);

    }

    return rec;
}

vec4 sky_color(Ray r)
{
    vec3 unit_direction = vec_unit(r.direction);
    float t = acos(unit_direction.y);
    float p = atan(-unit_direction.z, unit_direction.x) + 3.1415;
    float u = p * (1 / (2 * 3.1415));
    float v = t * (1 / 3.1415);

    vec3 rc = texture(skymap, vec2(u, v)).rgb;

    return vec4(srgb_to_linear(rc), 1);
}

vec4 ray_color(Ray r, float x, float y, int maxv)
{

    int last_hit = -1;
    HittableRecord rec = world_hit(r, x, y);
    vec4 result = vec4(1);

    int depth = 0;

#ifdef SHOW_BVH
    return vec4(float(rec.tcount), float(rec.tcount) / 256, float(rec.tcount) / 512, 1);
#endif
    if (!rec.hitted)
    {

        return sky_color(r);
    }

    while (true)
    {
        MaterialRecord material = material_hit(rec, r);

        if (material.do_scatter)
        {
            r = material.scatter;
            result = result * vec4(material.attenuation, 1.0);
        }
        else
        {
            result = result * (vec4(material.emitted, 1.0));

            return result;
        }

        rec = world_hit(r, x, y);
        depth += 1;
        if (rec.hitted == false)
        {
            result = result * sky_color(r);

            return vec4(result);
        }
        else if (depth > maxv)
        {
            return vec4(result);
        }
    }
}

#endif