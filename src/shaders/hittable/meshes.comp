#ifndef MESHES_COMP
#define MESHES_COMP

#include "hittable/bvh.comp"
#include "hittable/hittable.comp"
#include "hittable/material.comp"
#include "utils/color.comp"
#include "utils/ray.comp"

// #define SHOW_BVH

layout(std140, binding = 2) readonly buffer MeshesBufData
{
    vec4 buf_datas[];
};

struct Mesh
{
    uint type;
    uint material_type;
    uint material_data_start;
    uint material_data_end;
    uint mesh_data_start;
    uint mesh_data_end;
    vec4 aabb1;
    vec4 aabb2;
};

layout(std140, binding = 3) readonly buffer MeshesBuf
{
    Mesh meshes[];
};

layout(std140, binding = 5) readonly buffer BvhBuf
{
    Bvh bvhs[];
};
layout(binding = 6) uniform sampler2DArray textures;
layout(binding = 7) uniform sampler2D skymap;
layout(std140, binding = 8) readonly buffer Lights
{
    uint lights[];
};
#define FROM_SIBLING 1
#define FROM_PARENT 2
#define FROM_CHILD 3

// size in vec4
#define VERTEX_SIZE 4

PbrtTexture material_load_tex(int begin, int off)
{
    const int scale = 3;
    PbrtTexture result;
    result.id = int(buf_datas[begin + off * 3].x);
    result.tid = int(buf_datas[begin + off * 3].y);
    result.factor = buf_datas[begin + off * 3 + 1];
    result.offset = buf_datas[begin + off * 3 + 2].xy;
    result.scale = buf_datas[begin + off * 3 + 2].zw;
    return result;
}
HittableRecord process_leaf(Ray r, int id, int vert, float cmin, float cmax)
{
    Mesh current_mesh = meshes[id];

    vec3 pa = buf_datas[current_mesh.mesh_data_start + vert * VERTICES_SIZE + 0 * VERTEX_SIZE].xyz;
    vec3 pb = buf_datas[current_mesh.mesh_data_start + vert * VERTICES_SIZE + 1 * VERTEX_SIZE].xyz;
    vec3 pc = buf_datas[current_mesh.mesh_data_start + vert * VERTICES_SIZE + 2 * VERTEX_SIZE].xyz;

    HittableRecord res = hit_triangle(cmin, cmax, r, pa, pb, pc);

    res.mesh_id = id;
    res.vert_id = vert;

    if (res.hitted)
    {
        float alpha = material_load_tex(int(current_mesh.material_data_start), 0).factor.w;
        if (random() > (alpha))
        {
            res.hitted = false;
        }
    }

    return res;
}

struct PdfSampleRecord
{
    vec3 random_point;
    float area;
    float pdf;
    uint id;
};

PdfSampleRecord sample_triangle(uint id, uint mid)
{
    vec3 pa = buf_datas[id + 0 * VERTEX_SIZE].xyz;
    vec3 pb = buf_datas[id + 1 * VERTEX_SIZE].xyz;
    vec3 pc = buf_datas[id + 2 * VERTEX_SIZE].xyz;

    vec3 ab = pb - pa;
    vec3 ac = pc - pa;
    vec3 p = pa + random() * ab + random() * ac;
    float area = 0.5 * length(cross(ab, ac));
    float pdf = 1.0 / area;
    return PdfSampleRecord(p, area, pdf, mid);
}
PdfSampleRecord sample_random(vec3 origin, vec3 n)
{
    int id = clamp(int(random() * float(lights.length())), 0, lights.length()-1);

    Mesh current_mesh = meshes[lights[id]];

    uint vid = current_mesh.mesh_data_start + int(random() * float((current_mesh.mesh_data_end - current_mesh.mesh_data_start) / VERTEX_SIZE - 1)) * VERTEX_SIZE;

    return sample_triangle(vid, lights[id]);
}

HittableRecord traverse_bvh_stack(Ray r, float cmin_f, float cmax_f);


bool aabb_hit(Ray r, Bvh cur, float t_min, float t_max)
{
    const vec3 invd = (r.inv_direction);
    vec3 t0 = ((cur.aabb_min.xyz - r.origin) * invd);
    vec3 t1 = ((cur.aabb_max.xyz - r.origin) * invd);
    if (invd.x < 0.0f)
    {
        // if(dir.x < 0)
        // swap(t0.x, t1.x);
        float _temp = t0.x;
        t0.x = t1.x;
        t1.x = _temp;
    }
    if (invd.y < 0.0f)
    {
        //  if(dir.y < 0)
        // swap(t0.y, t1.y);
        float _temp = t0.y;
        t0.y = t1.y;
        t1.y = _temp;
    }
    if (invd.z < 0.0f)
    {
        // if(dir.z < 0)
        // swap(t0.z, t1.z);
        float _temp = t0.z;
        t0.z = t1.z;
        t1.z = _temp;
    }
    t_min = max(t0.y, t_min);
    t_min = max(t0.z, t_min);
    t_min = max(t0.x, t_min);

    t_max = min(t1.x, t_max);
    t_max = min(t1.z, t_max);
    t_max = min(t1.y, t_max);
    if (t_max < t_min)
    {
        return false;
    }

    return true;
}
bool aabb_hit2(Ray r, Bvh cur, float t_min, float t_max)
{

    vec3 inv_dir = vec3(1) / r.direction;
    vec3 t0 = ((cur.aabb_min.xyz - r.origin) / r.direction);
    vec3 t1 = ((cur.aabb_max.xyz - r.origin) / r.direction);
    vec3 tmax = max(t0, t1);
    vec3 tmin = min(t0, t1);

    return vec3_min_comp(tmax) >= vec3_max_comp(tmin);
}

#define STACK_SIZE 64

 struct CacheRecord 
{
    HittableRecord result;
    Ray ray;
};
int cache_off = 0;
int cache_len = 0;
CacheRecord cache[3];
HittableRecord traverse_bvh_stack(Ray r, float cmin_f, float cmax_f)
{

    int stack[STACK_SIZE];

    int current = bvhs[0].la;
    float cmin = cmin_f;
    float cmax = cmax_f;
    int i = 0;
    int sp = 0;
    int depth = 0;
    stack[sp] = 0;
    sp++;
    HittableRecord res;
    res.hitted = false;

#ifdef SHOW_DEPTH
    Bvh dcur = bvhs[stack[0]];

    if (aabb_hit(r, bvhs[0], cmin, cmax))
    {
        depth++;
    }
#endif
    while (sp > 0 && sp < STACK_SIZE)
    {
        sp--; // pop

        Bvh cur = bvhs[stack[sp]];
        if (cur.is_next_a_bvh == 0)
        {

            HittableRecord rec2 = process_leaf(r, cur.la, cur.lb, cmin, cmax);
            if (rec2.hitted)
            {
                cmax = rec2.t;
                res = rec2;

#ifdef SHOW_DEPTH
                depth = max(depth, sp + 4);
#endif
            }
            if (cur.ra != 0)
            {
                rec2 = process_leaf(r, cur.ra, cur.rb, cmin, cmax);
                if (rec2.hitted)
                {
                    cmax = rec2.t;
                    res = rec2;

#ifdef SHOW_DEPTH
                    depth = max(depth, sp + 4);
#endif
                }
            }
            /*
            HittableRecord rec2 = process_leaf(r, cur.la, cur.r, cmin, cmax);
            if (rec2.hitted)
            {
                cmax = rec2.t;
                res = rec2;
            }*/
        }
        else
        {
            Bvh lb = bvhs[cur.la];
            Bvh rb = bvhs[cur.ra];

            if (aabb_hit(r, lb, cmin, cmax))
            {
                stack[sp] = cur.la;

                sp++;

#ifdef SHOW_DEPTH
                depth = max(depth, sp + 2);
#endif
            }
            if (aabb_hit(r, rb, cmin, cmax))
            {

                stack[sp] = cur.ra;

                sp++;
#ifdef SHOW_DEPTH
                depth = max(depth, sp + 2);
#endif
            }
        }
    }

#ifdef SHOW_DEPTH
    res.depth = depth;
#endif
    return res;
}

// # Temporary way of getting the normal vector from a reflection and a input vector
vec3 inverse_reflection(vec3 dir, vec3 reflected)
{
    return (reflected - 2.0 * dot(reflected, -dir) * (-dir));
}

vec3 material_tex_query(PbrtTexture tex, vec2 uv)
{
    mat3 translation = mat3(1, 0, 0, 0, 1, 0, tex.offset.x, tex.offset.y, 1);

    mat3 scale = mat3(tex.scale.x * 1, 0, 0, 0, tex.scale.y * 1, 0, 0, 0, 1);

    mat3 matrix = translation * scale;
    vec2 uvTransformed = (matrix * vec3(uv.xy, 1)).xy;
    vec3 result = texture(textures, vec3(uvTransformed, tex.id)).rgb;
    return result;
}

vec3 cosine_sample_hemisphere(float r1, float r2)
{
    float phi = 2.0 * M_PI * r1;

    float rt_r2 = sqrt(r2);
    float x = cos(phi) * rt_r2;
    float y = sin(phi) * rt_r2;

    float z = sqrt(max(0.0, 1.0 - x * x - y * y));
    return normalize(vec3(x, y, z));
}

vec3 importance_sample(float r, float r1, float r2)
{
    float phi = 2.0 * M_PI * r1;

    float rt_r2 = sqrt(r2);
    float z = sqrt(1 - r2);
    float x = r * cos(phi) * rt_r2;
    float y = r * sin(phi) * rt_r2;

    return normalize(vec3(x, y, z));
}

PdfSampleRecord sample_point(vec3 N, vec3 point)
{

    bool continue_v = true;
    int maxv = 0;
    while (continue_v && maxv++ < 4)
    {
        PdfSampleRecord pdf_sample = sample_random(point, N);
        vec3 dir = -(point - pdf_sample.random_point);

        if (dot(dir, N) <= 0.001)
        {
            continue;
        }
        else
        {
            vec3 cdir = normalize(dir);
            Ray new_ray = Ray(point, cdir, 1 / cdir);
            const float cmin = 0.00001f;
            const float cmax = 100000.f;

          //  HittableRecord rec = traverse_bvh_stack(new_ray, cmin, cmax);
          //  if (rec.hitted)
           // {
                //if (rec.mesh_id != pdf_sample.id)
                //{
                //    continue;
                //}
                float dist = length(dir);

                dir = cdir;
                float pdf = dist * dist / max(dot(N, dir) * pdf_sample.area, 0.01);

                pdf_sample.pdf = pdf;

                return pdf_sample;
                //      mvr = dumb_brdf(r, record, roughness_value, metal_value, result.attenuation, dir, N);
//            }

        }
    }
    PdfSampleRecord pdf_sample = sample_random(point, N);
    vec3 dir = -(point - pdf_sample.random_point);
    float dist = length(dir);

    dir = normalize(dir);

    float pdf = dist * dist / (dot(N, dir) * pdf_sample.area);
    pdf_sample.pdf = 0;
    return pdf_sample;
}

MaterialRecord material_hit(HittableRecord record, Ray r)
{
    Mesh current_mesh = meshes[record.mesh_id];

    MaterialRecord result;
    result.emitted = vec3(0, 0, 0);

    PbrtTexture albedo_T = material_load_tex(int(current_mesh.material_data_start), 0);
    PbrtTexture normal_T = material_load_tex(int(current_mesh.material_data_start), 1);
    PbrtTexture metallic_roughness_T = material_load_tex(int(current_mesh.material_data_start), 2);
    PbrtTexture emit_T = material_load_tex(int(current_mesh.material_data_start), 3);

    int base = int(albedo_T.id);
    int base_tid = int(albedo_T.tid);

    int metal = int(metallic_roughness_T.id);
    int metal_tid = int(metallic_roughness_T.tid);

    int normal = int(normal_T.id);
    int normal_tid = int(normal_T.tid);

    int emitid = int(emit_T.id);

    vec3 emit = emit_T.factor.xyz;

    if (emitid >= 0)
    {
        emit *= material_tex_query(emit_T, record.uv).xyz;
    }

    result.do_scatter = true;
    if (length(emit) > 0.9)
    {
        result.do_scatter = false;
    }

    vec3 fact = albedo_T.factor.xyz;
    float alpha = albedo_T.factor.w;
    if (base < 0)
    {
        result.attenuation = fact;
    }
    else
    {
        vec2 fuv = record.uv;
        if (base_tid == 1)
        {
            fuv = record.uv2;
        }
        result.attenuation = material_tex_query(albedo_T, fuv) * fact;

        alpha = 1.0;
        //        alpha = texture(textures, vec3(record.uv, base)).w;
    }

    vec3 T = ((record.tangent));
    vec3 N = ((record.normal));
    vec3 B = (record.bittangent);

    vec3 og_normal = record.normal;

    vec3 unit_direction = vec_unit(r.direction);

    if (normal >= 0)
    {
        vec3 normalv = vec3(1);
        vec2 fuv = record.uv;
        if (normal_tid == 1)
        {
            fuv = record.uv2;
        }
        normalv = (material_tex_query(normal_T, fuv).rgb) * 2.0 - vec3(1.0);

        normalv = (normalize(normalv) * vec3(normal_T.factor.xy, 1.0));

        record.normal = normalize((normalv.x) * T + (normalv.y) * B + (normalv.z) * N);
    }

    // recreate a coordinate system

    // https://www.pbr-book.org/3ed-2018/Geometry_and_Transformations/Vectors#CoordinateSystemfromaVector
    N = record.normal;
    if (abs(N.x) > abs(N.y))
    {
        T = normalize(vec3(-N.z, 0, N.x) * inversesqrt(N.x * N.x + N.z * N.z));
    }
    else
    {
        T = normalize(vec3(0, N.z, -N.y) * inversesqrt(N.y * N.y + N.z * N.z));
    }
    B = normalize(cross(N, T));
// debug
#if 0
    if (true)
    {

        for (int i = 0; i < lights.length(); i++)
        {
            if (record.mesh_id == lights[i])
            {
                result.emitted = vec3(1, 1, 1);
                result.do_scatter = false;
                return result;
            }
        }
        result.emitted = (vec3(0, 0, 1));
        result.do_scatter = false;
        return result;
    }
#endif

    vec3 metal_roughness = vec3(1, 1, 1);
    if (metal >= 0)
    {
        vec2 fuv = record.uv;
        if (metal_tid == 1)
        {
            fuv = record.uv2;
        }
        metal_roughness = material_tex_query(metallic_roughness_T, fuv);
    }

    metal_roughness *= metallic_roughness_T.factor.xyz;

    result.emitted = emit;

    // y = roughtness
    // z = metalness
    vec3 oattenuation = result.attenuation;

    vec3 dir;

    const float idx = 1.5;

    float refract_ratio = 1.0 / idx;
    // if (!record.front)
    // {
    //     refract_ratio = idx;
    // }

    float cos_theta = min((dot(-unit_direction, N)), 1.0);
    float sin_theta = sqrt(1.0 - cos_theta * cos_theta);

    float diffuse_ratio = 1.0 - (metal_roughness.z * metal_roughness.z);
    vec3 H = N;

    float roughness_value = clamp(metal_roughness.y, 0.0001, 1);
    float metal_value = clamp(metal_roughness.z, 0, 1);
    bool is_specular = false;
    if (reflectance(cos_theta, refract_ratio) > random()) // specular
    {
        is_specular = true;
        // https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf

        //  dir = reflect(unit_direction, record.normal);
        // dir = vec_unit(dir + (vec3_random_unit() * (random())) * clamp(metal_roughness.y, 0, 1));
        H = importance_sample(roughness_value, random(), random());

        H = normalize(H.x * T + H.y * B + H.z * N);
        if (dot(H, unit_direction) > 0)
        {
            H = -H;
        }
        dir = normalize(reflect(unit_direction, H));
    }
    else
    {
        float r1 = random();
        float r2 = random();
        if (random() < (metal_value * 0.5))
        {
            H = importance_sample(roughness_value, r1, r2);

            H = normalize(H.x * T + H.y * B + H.z * N);

            if (dot(H, unit_direction) > 0)
            {
                H = -H;
            }
            dir = reflect(unit_direction, H);
        }
        else
        {
            dir = cosine_sample_hemisphere(r1, r2);

            // V= -I
            // H = (V + L) / 2 <=> = norm(V + L)
            //     H = normalize(dir + (-unit_direction));
            //     if(dot(H, unit_direction) > 0)
            //     {
            //         H = -H;
            //     }
        }
        //  vec3 ndir = vec_unit(record.normal+ (vec3_random_unit() * (random())) *  clamp(metal_roughness.y, 0, 1));

        dir = vec_unit(dir);
    }

    MaterialValRecord mvr = dumb_brdf(r, record, roughness_value, metal_value, result.attenuation, dir, N);


    if ( result.do_scatter  &&!is_specular && random() < 0.5 )
    {

        vec3 olddir = dir;

        int maxv = 0;

        PdfSampleRecord pdf_sample = sample_point(N, record.point);

        if (pdf_sample.pdf == 0)
        {
            result.pdf = 1;

            result.scatter_pdf = 1;

        //    result.emitted = vec3(0, 1, 0);
        //    result.do_scatter = false;
        //    return result;
        }
        else
        {

            dir = normalize(-(record.point - pdf_sample.random_point));

            mvr = dumb_brdf(r, record, roughness_value, metal_value, result.attenuation, dir, N);
            result.scatter_pdf = mvr.pdf;
            result.attenuation = mvr.color;
            result.pdf = pdf_sample.pdf;
        //    result.emitted = vec3(1, 0, 0);
        //    result.do_scatter = false;
        //    return result;
        }
    }
    else
    {
        result.pdf = 1;

        result.scatter_pdf = 1;
    }

    result.attenuation = mvr.color;
// debug
#if 0
    if(true)
    {
        result.emitted = vec3(pdf, result.scatter_pdf, 0);
        result.do_scatter = false;
        return result;
    }
#endif

    result.scatter = Ray(record.point, dir, vec3(1));

    result.scatter.inv_direction = vec3(1) / result.scatter.direction;

    return result;
}

HittableRecord world_hit(Ray r)
{

    float cmin = 0.00001f;
    float cmax = 100000.f;

    HittableRecord rec = traverse_bvh_stack(r, cmin, cmax);
    if (rec.hitted)
    {
        Mesh current_mesh = meshes[rec.mesh_id];
        uint start = current_mesh.mesh_data_start + rec.vert_id * VERTICES_SIZE;

        vec3 pa = buf_datas[VERTEX_SIZE * 0 + start].xyz;
        vec3 na = buf_datas[VERTEX_SIZE * 0 + start + 1].xyz;
        vec3 ta = (buf_datas[VERTEX_SIZE * 0 + start + 2].xyz);
        vec2 uv1a = buf_datas[VERTEX_SIZE * 0 + start + 3].xy;
        vec2 uv2a = buf_datas[VERTEX_SIZE * 0 + start + 3].zw;

        vec3 pb = buf_datas[VERTEX_SIZE * 1 + start].xyz;
        vec3 nb = buf_datas[VERTEX_SIZE * 1 + start + 1].xyz;
        vec3 tb = (buf_datas[VERTEX_SIZE * 1 + start + 2].xyz);
        vec2 uv1b = buf_datas[VERTEX_SIZE * 1 + start + 3].xy;
        vec2 uv2b = buf_datas[VERTEX_SIZE * 1 + start + 3].zw;

        vec3 pc = buf_datas[VERTEX_SIZE * 2 + start].xyz;
        vec3 nc = buf_datas[VERTEX_SIZE * 2 + start + 1].xyz;
        vec3 tc = (buf_datas[VERTEX_SIZE * 2 + start + 2].xyz);
        vec2 uv1c = buf_datas[VERTEX_SIZE * 2 + start + 3].xy;
        vec2 uv2c = buf_datas[VERTEX_SIZE * 2 + start + 3].zw;

        float tsign = buf_datas[start + 2].w;
        vec3 edge_1 = pb - pa;
        vec3 edge_2 = pc - pa;

        rec.normal = normalize((na * (1 - rec.uv.x - rec.uv.y) + nb * (rec.uv.x) + nc * (rec.uv.y)));

        vec3 n2 = (normalize(cross(edge_1, edge_2)));

        rec.geometry_normal = n2;

        rec.tangent = normalize((ta * (1 - rec.uv.x - rec.uv.y) + tb * (rec.uv.x) + tc * (rec.uv.y)));

        rec.bittangent = normalize(cross(rec.normal, rec.tangent)) * tsign;

        vec2 final = (uv1a * (1.0 - rec.uv.x - rec.uv.y) + uv1b * (rec.uv.x) + uv1c * (rec.uv.y));
        vec2 final2 = (uv2a * (1.0 - rec.uv.x - rec.uv.y) + uv2b * (rec.uv.x) + uv2c * (rec.uv.y));

        rec.uv = final;
        rec.uv2 = final2;

        rec = update_face_normal(rec, r, rec.normal);
    }

    return rec;
}

float map(float value, float min1, float max1, float min2, float max2)
{
    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

vec3 light_off = vec_unit(vec3(-3.9618, -3.142, -1.3474));
vec4 sky_color(Ray r)
{

    // return vec4(vec3(0.9922, 0.9843, 0.8275) * (100), 1);
    vec3 unit_direction = vec_unit(r.direction);
    float rad = (0.009285) / 4;
    float ldir = map(clamp(dot(-light_off, unit_direction), 1.0 - rad, 1.0), 1.0 - rad, 1.0, 0, 1);

    return vec4(0, 0, 0, 1);
    return vec4(mix(vec3(0.23, 0.36, 0.41), vec3(0.9922, 0.9843, 0.8275) * (100), ldir), 1);
    float t = acos(unit_direction.y);
    float p = atan(-unit_direction.z, unit_direction.x) + 3.1415;
    float u = p * (1 / (2 * 3.1415));
    float v = t * (1 / 3.1415);

    vec3 rc = texture(skymap, vec2(u, v)).rgb;

    return vec4(srgb_to_linear(rc), 1);
}

vec4 ray_color(Ray r, float x, float y, uint maxv)
{

    int last_hit = -1;
    HittableRecord rec = world_hit(r);
    vec4 result = vec4(1);

    int depth = 0;

#ifdef SHOW_DEPTH
    return vec4(float(rec.depth) / 32, float(rec.depth) / 256, float(rec.depth) / 512, 1);
#endif
    if (!rec.hitted)
    {
        //  return vec4(0, 1, 0, 1);
        return sky_color(r);
    }
    float accum = 1.0;
    while (depth <= maxv)
    {
        MaterialRecord material = material_hit(rec, r);

        if (material.do_scatter)
        {
            r = material.scatter;
            result = result * (vec4(material.attenuation, 1.0) * material.scatter_pdf) / (material.pdf+0.001);
        }
        else
        {
            result = result * (vec4(material.emitted, 1.0));

            return result;
        }

        depth += 1;

        rec = world_hit(r);

        if (rec.hitted == false)
        {
            result = result * sky_color(r);

            return result;
        }
    }
    //    r.direction = -light_off;
    //    rec = world_hit(r, x, y);

    //    if(!rec.hitted)
    //    {
    //        result = result * sky_color(r);
    //        return result;
    //
    //    }
    return result;
}

#endif
