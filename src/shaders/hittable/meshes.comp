#ifndef MESHES_COMP
#define MESHES_COMP

#include "hittable/brdf.comp"
#include "hittable/bvh.comp"
#include "hittable/hittable.comp"
#include "hittable/material.comp"
#include "hittable/sampling.comp"
#include "hittable/textures.comp"
#include "layouts.comp"
#include "utils/camera.comp"
#include "utils/color.comp"
#include "utils/ray.comp"

bool any_hit(Ray r, float maxv)
{
    rayQueryEXT rayQuery;
    rayQueryInitializeEXT(rayQuery, TLAS, gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsSkipClosestHitShaderEXT, 0xFF, r.origin, 0.0001, r.direction, maxv);

    // Start traversal: return false if traversal is complete
    while (rayQueryProceedEXT(rayQuery))
    {
    }
    bool front = false;

    // Returns type of committed (true) intersection
    if (rayQueryGetIntersectionTypeEXT(rayQuery, true) != gl_RayQueryCommittedIntersectionNoneEXT)
    {
        return true;
        //		//const int primitiveId = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);
    }
    return false;
}
HittableRecord world_hit(Ray r, int denya, int denyb)
{

    float cmin = 0.00001f;
    float cmax = 100000.f;

    HittableRecord rec;
    rec.hitted = false;
    // traverse_bvh_stack(r, cmin, cmax);

    rayQueryEXT rayQuery;
    rayQueryInitializeEXT(rayQuery, TLAS, gl_RayFlagsOpaqueEXT, 0xFF, r.origin, cmin, r.direction, cmax);

    // Start traversal: return false if traversal is complete
    while (rayQueryProceedEXT(rayQuery))
    {
    }
    bool front = false;

    // Returns type of committed (true) intersection
    if (rayQueryGetIntersectionTypeEXT(rayQuery, true) != gl_RayQueryCommittedIntersectionNoneEXT)
    {
        rec.hitted = true;
        rec.mesh_id = rayQueryGetIntersectionInstanceCustomIndexEXT(rayQuery, true);
        rec.vert_id = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);
        // rec.point = r.origin + r.direction * rayQueryGetIntersectionTEXT(rayQuery);
        //  rec.normal = rayQueryGetIntersectionInstanceIntersectionNormalEXT(rayQuery, true);

        vec2 barycentrics = rayQueryGetIntersectionBarycentricsEXT(rayQuery, true);
        vec3 barycentrics3 = vec3(1.0 - barycentrics.x - barycentrics.y, barycentrics.x, barycentrics.y);
        front = rayQueryGetIntersectionFrontFaceEXT(rayQuery, true);
        rec.uv = barycentrics.xy;

        //		//const int primitiveId = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);
    }
    if (rec.hitted)
    {
        Mesh current_mesh = meshes[nonuniformEXT(rec.mesh_id)];
        uint start = current_mesh.mesh_data_start + rec.vert_id * VERTICES_SIZE;

        vec3 pa = buf_datas[nonuniformEXT(VERTEX_SIZE * 0 + start)].xyz;
        vec3 na = buf_datas[nonuniformEXT(VERTEX_SIZE * 0 + start + 1)].xyz;
        vec3 ta = (buf_datas[nonuniformEXT(VERTEX_SIZE * 0 + start + 2)].xyz);
        vec2 uv1a = buf_datas[nonuniformEXT(VERTEX_SIZE * 0 + start + 3)].xy;
        vec2 uv2a = buf_datas[nonuniformEXT(VERTEX_SIZE * 0 + start + 3)].zw;

        vec3 pb = buf_datas[nonuniformEXT(VERTEX_SIZE * 1 + start)].xyz;
        vec3 nb = buf_datas[nonuniformEXT(VERTEX_SIZE * 1 + start + 1)].xyz;
        vec3 tb = (buf_datas[nonuniformEXT(VERTEX_SIZE * 1 + start + 2)].xyz);
        vec2 uv1b = buf_datas[nonuniformEXT(VERTEX_SIZE * 1 + start + 3)].xy;
        vec2 uv2b = buf_datas[nonuniformEXT(VERTEX_SIZE * 1 + start + 3)].zw;

        vec3 pc = buf_datas[nonuniformEXT(VERTEX_SIZE * 2 + start)].xyz;
        vec3 nc = buf_datas[nonuniformEXT(VERTEX_SIZE * 2 + start + 1)].xyz;
        vec3 tc = (buf_datas[nonuniformEXT(VERTEX_SIZE * 2 + start + 2)].xyz);
        vec2 uv1c = buf_datas[nonuniformEXT(VERTEX_SIZE * 2 + start + 3)].xy;
        vec2 uv2c = buf_datas[nonuniformEXT(VERTEX_SIZE * 2 + start + 3)].zw;

        float tsign = buf_datas[nonuniformEXT(start + 2)].w;
        vec3 edge_1 = pb - pa;
        vec3 edge_2 = pc - pa;
        rec.normal = normalize((na * (1 - rec.uv.x - rec.uv.y) + nb * (rec.uv.x) + nc * (rec.uv.y)));

        vec3 n2 = (normalize(cross(edge_1, edge_2)));

        rec.geometry_normal = n2;

        rec.tangent = normalize((ta * (1 - rec.uv.x - rec.uv.y) + tb * (rec.uv.x) + tc * (rec.uv.y)));

        rec.bittangent = normalize(cross(rec.normal, rec.tangent)) * tsign;

        rec.point = pa * (1 - rec.uv.x - rec.uv.y) + pb * (rec.uv.x) + pc * (rec.uv.y);
        vec2 final = (uv1a * (1.0 - rec.uv.x - rec.uv.y) + uv1b * (rec.uv.x) + uv1c * (rec.uv.y));
        vec2 final2 = (uv2a * (1.0 - rec.uv.x - rec.uv.y) + uv2b * (rec.uv.x) + uv2c * (rec.uv.y));

        rec.uv = final;
        rec.uv2 = final2;

        // rec = update_face_normal(rec, r, rec.normal);

        rec.front = front;

        if (dot(r.direction, rec.normal) > 0)
        {
            rec.front = false;
            rec.normal = -rec.normal;
        }
    }

    return rec;
}

float map(float value, float min1, float max1, float min2, float max2)
{
    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

vec3 light_off = -vec_unit(vec3(-1.99851, 1.53129, -3.35852));
vec4 sky_color(Ray r)
{
    // return vec4(0);
    //   //return vec4(1);
    //    return vec4(vec3(0.251, 0.612, 1), 1);
    vec3 unit_direction = vec_unit(r.direction);
    float rad = (0.009285) / 40;
    float ldir = map(clamp(dot(-light_off, unit_direction), 1.0 - rad, 1.0), 1.0 - rad, 1.0, 0, 1);

    //  return vec4(0, 0, 0, 1);
    // return vec4(mix(vec3(0.23, 0.36, 0.41), vec3(0.9922, 0.9843, 0.8275) * (100), ldir), 1);
    // return vec4(mix(vec3(0), vec3(1) * (100), ldir), 1);

    float t = acos(unit_direction.y);
    float p = atan(-unit_direction.z, unit_direction.x) + 3.1415;
    float u = p * (1 / (2 * 3.1415));
    float v = t * (1 / 3.1415);

    vec3 rc = texture(skymap, vec2(u, v)).rgb;

    return vec4(srgb_to_linear(rc), 1);
}

struct ExportRecord
{
    vec3 pos;
    vec3 normal;
    vec3 albedo;
};

vec4 ray_color(Ray r, float x, float y, uint maxv, out ExportRecord export_record)
{

    int last_hit = -1;
    HittableRecord rec = world_hit(r, -1, -1);
    vec4 result = vec4(1);
    int tdepth = 0;
    int depth = 0;

    // if(any_hit(r, 1000))
    // {
    //     return vec4(0,0,0,1);
    // }
    // else
    // {
    //     return vec4(1,1,1,1);
    // }
#ifdef SHOW_DEPTH

    if (rec.depth < 5)
    {
        return vec4(0, 0, float(rec.depth) / 10 + 0.5, 1);
    }
    else if (rec.depth < 32)
    {
        return vec4(float(rec.depth) / 64.0 + 0.5, 0, 0, 1);
    }
    else
    {
        return vec4(0, 1.0, 0, 1);
    }
#endif
    if (!rec.hitted)
    {
        return sky_color(r);
    }
    else
    {
        //     return vec4(rec.uv.x, rec.uv.y, 0, 1);
    }
    float accum = 1.0;
    int transparent_depth = 8;

    while (depth < maxv && transparent_depth > 0)
    {
        MaterialRecord material = material_hit_info(rec, r);
        MaterialQueryRecord query;

        if (depth == 0)
        {
            export_record.pos = rec.point;
            export_record.normal = material.N;
            export_record.albedo = material.albedo;
        }

        // return vec4(material.,0,0,1);
        if (material.do_scatter)
        {

            if (material.transparent)
            {
                query = material_query_pdf(material, r, 1);
                query = material_update_attenuation(query, material);
                depth -= 1;
                transparent_depth -= 1;
                r = query.scatter;
                // result = result * vec4(1,0,0,1);
                // result = result * (vec4(query.attenuation, 1.0) * query.scatter_pdf) / (query.pdf + 0.001);
            }
            else
            {

                query = material_query_pdf(material, r, (depth + 2) == maxv ? 1 : 0.5);
                query = material_update_attenuation(query, material);
                //       query.attenuation =  material.albedo;
                r = query.scatter;
                result = result * (vec4(query.attenuation, 1.0) * query.scatter_pdf) / (query.pdf + 0.00001);
                //  result.w = 1.0;
            }
        }
        else
        {

            material.emitted = (material.emitted) * abs(dot(material.N, r.direction)) / length(rec.point - r.origin);

            // material.emitted = material.emitted * ;
            result = result * (vec4(material.emitted, 1.0));

            return result;
        }

        depth += 1;
        rec = world_hit(r, rec.mesh_id, rec.vert_id);

        if (rec.hitted == false)
        {
            //  return vec4(material.albedo * result.rgb, 1.0);
            result = result * sky_color(r);

            return result;
        }
    }
    return vec4(0);
};

#ifdef OLD

bool bidir_raytrace(inout vec4 result, camera cam, Ray camera_ray, Ray light_ray, uint maxv, out vec3 origin)
{
    HittableRecord cam_rec = world_hit(camera_ray, -1, -1);
    if (!cam_rec.hitted)
    {
        return false;
    }
    HittableRecord light_rec = world_hit(light_ray, -1, -1);

    if (!light_rec.hitted)
    {
        return false;
    }
    uint depth = 0;
    float accum = 1.0;
    int transparent_depth = 8;
    vec4 light_result = result;
    result = vec4(1);
    float summed_ior = 1;

    while (depth < maxv && transparent_depth > 0)
    {
        MaterialRecord cam_material = material_hit_info(cam_rec, camera_ray);
        MaterialRecord light_material = material_hit_info(light_rec, light_ray);
        Ray prev_camera_ray = camera_ray;
        Ray prev_light_ray = light_ray;

        bool hit_camera = false;
        if (true)
        {
            PdfSampleRecord rsample;
            rsample.random_point = cam_material.point;
            rsample.light_normal = normalize(cam_material.N);
            MaterialQueryRecord query;

            if (light_material.transparent)
            {
                query = material_query_camera(light_material, light_ray, rsample, hit_camera, 1);

                // query = material_query_pdf(light_material, light_ray, 10000);
                query = material_update_attenuation(query, light_material);

                // depth -= 1;
                // transparent_depth -= 1;
                light_ray = query.scatter;
                // result = result * vec4(1,0,0,1);
                // result = result * (vec4(query.attenuation, 1.0) * query.scatter_pdf) / (query.pdf + 0.001);
            }
            else
            {
                query = material_query_camera(light_material, light_ray, rsample, hit_camera, (depth + 2) == maxv ? 0 : 0.5);

                // query = material_query_pdf(light_material, light_ray, 10000);
                query = material_update_attenuation(query, light_material);
                //       query.attenuation =  material.albedo;
                light_ray = query.scatter;
                light_result = light_result * (vec4(query.attenuation, 1.0) * query.scatter_pdf) / (query.pdf + 0.00001);
                //  result.w = 1.0;
            }
        }
        else
        {
            return false;
        }
        bool hit_light = false;
        // return vec4(material.,0,0,1);
        if (cam_material.do_scatter)
        {
            PdfSampleRecord rsample;
            rsample.random_point = light_material.point;
            rsample.light_normal = normalize(light_material.N);
            MaterialQueryRecord query;

            if (cam_material.transparent)
            {
                query = material_query_camera(cam_material, camera_ray, rsample, hit_light, 1);
                query = material_update_attenuation(query, cam_material);
                depth -= 1;
                transparent_depth -= 1;
                camera_ray = query.scatter;
            }
            else
            {
                query = material_query_camera(cam_material, camera_ray, rsample, hit_light, (depth + 2) == maxv ? 0 : 0.5);
                summed_ior *= query.effective_ior;

                query = material_update_attenuation(query, cam_material);
                //       query.attenuation =  material.albedo;
                camera_ray = query.scatter;

                result = result * (vec4(query.attenuation, 1.0) * query.scatter_pdf) / (query.pdf + 0.00001);
                //  result.w = 1.0;
            }
        }
        else
        {
            cam_material.emitted = (cam_material.emitted) * abs(dot(cam_material.N, camera_ray.direction)) / length(cam_rec.point - camera_ray.origin);

            //  // material.emitted = material.emitted * ;
            result = result * (vec4(cam_material.emitted, 1.0));
            // result= light_result;
            // return result;
            return true;
        }

        if (hit_light && hit_camera)
        {
            float dist = (length(-(cam_rec.point - light_ray.origin)));
            if (!any_hit(camera_ray, dist))
            {
                result = result * light_result;
                return true;
            }
        }

        // float dist = (length(-(cam_rec.point - light_ray.origin)));

        // if (hit_light && !any_hit(camera_ray, dist) && light_ray.scatter)
        // {
        //     result = result * light_result;
        //     return true;
        // }
        //  float deddlta = ubo.fov / 2.0;
        // float vt = 1 -tan(((M_PI / 180.f) * (ubo.fov)) / 2.f);

        // if(!hit_camera && (dot(dir_to_cam, r.direction)) > 0.99 && (dot(dir_to_cam, -cam.to)) > 0.99)
        // {
        //     hit_camera = true;
        // }

        depth += 1;
        cam_rec = world_hit(camera_ray, -1, -1);
        light_rec = world_hit(light_ray, -1, -1);

        if (cam_rec.hitted == false || light_rec.hitted == false)
        {
            return false;
        }
    }
    return false;
};

#endif

bool bidir_raytrace(inout vec4 result, camera cam, Ray camera_ray, Ray light_ray, uint maxv, out vec3 origin)
{
    HittableRecord cam_rec = world_hit(camera_ray, -1, -1);
    if (!cam_rec.hitted)
    {
        result = sky_color(camera_ray);
        return true;
    }
    HittableRecord light_rec = world_hit(light_ray, -1, -1);

    if (!light_rec.hitted)
    {
        return false;
    }
    uint depth = 0;
    //   float accum = 1.0;
    int transparent_depth = 8;
    vec4 light_result = vec4(1);
    //  result = vec4(1);
    float summed_ior = 1;

    vec3 cam_geometry_n = cam_rec.normal;

    MaterialRecord light_material = material_hit_info(light_rec, light_ray);

    // ---- LIGHT
    while (depth < maxv && transparent_depth > 0 &&
           (light_material.is_transmissive || light_material.is_specular || !light_material.do_scatter || random() > 0.5))
    {

        bool hit_light = false;
        // return vec4(material.,0,0,1);
        if (light_material.do_scatter)
        {
            PdfSampleRecord rsample;
            // rsample.random_point = light_material.point;
            // rsample.light_normal = normalize(light_material.N);
            MaterialQueryRecord query;

            if (light_material.transparent)
            {
                query = material_query_camera(light_material, light_ray, rsample, hit_light, 100000);
                query = material_update_attenuation(query, light_material);
                depth -= 1;
                transparent_depth -= 1;
                light_ray = query.scatter;
            }
            else
            {
                query = material_query_camera(light_material, light_ray, rsample, hit_light, 100000);
                summed_ior *= query.effective_ior;

                query = material_update_attenuation(query, light_material);
                // query.attenuation = cam_material.albedo;
                light_ray = query.scatter;

                result = result * (vec4(query.attenuation, 1.0) * query.scatter_pdf) / (query.pdf + 0.00001);
                //  result.w = 1.0;
            }
        }
        else
        {
            return false;
        }
        // if(hit_light)
        // {
        //     break;
        // }

        depth += 1;
        light_rec = world_hit(light_ray, -1, -1);

        if (light_rec.hitted == false)
        {
            //       result = sky_color(light_ray);
            return false;
        }
        light_material = material_hit_info(light_rec, light_ray);
    }

    if (depth >= maxv)
    {
        return false;
    }
    //   result = vec4(abs(light_rec.point) / 4, 1);
    //   return true;
    depth = 0;
    transparent_depth = 8;

    while (depth < maxv && transparent_depth > 0)
    {
        MaterialRecord material = material_hit_info(cam_rec, camera_ray);
        MaterialQueryRecord query;

        vec3 light_geometry_n = light_rec.normal;

        bool hit_light = false;
        // return vec4(material.,0,0,1);
        if (material.do_scatter)
        {
            PdfSampleRecord rsample;
            rsample.random_point = light_material.point;

            rsample.light_normal = normalize(-light_ray.direction);
            if (material.transparent)
            {

                //     MaterialQueryRecord material_query_camera(MaterialRecord record, Ray r, PdfSampleRecord forced_record, out bool look_cam, float prob)

                query = material_query_camera(material, camera_ray, rsample, hit_light, 1);
                query = material_update_attenuation(query, material);
                depth -= 1;
                transparent_depth -= 1;
                camera_ray = query.scatter;
                // result = result * vec4(1,0,0,1);
                // result = result * (vec4(query.attenuation, 1.0) * query.scatter_pdf) / (query.pdf + 0.001);
            }
            else
            {
                query = material_query_camera(material, camera_ray, rsample, hit_light, 0.5);

                vec3 dir_to_cam = (-(cam_rec.point - light_material.point));

                // if (hit_camera)
                //! {
                //     result = vec4(cam_material.point, 1) / 8;
                //     return true;
                //  }

                float dist = (length(dir_to_cam));
                if (hit_light && (any_hit(query.scatter, dist)))
                {
                    hit_light = false;
                    query = material_query_camera(material, camera_ray, rsample, hit_light, 1000000000);
                }

                query = material_update_attenuation(query, material);
                //        query.attenuation = material.albedo;
                camera_ray = query.scatter;

                // if (!hit_light)
                //{

                light_result = light_result * (vec4(query.attenuation, 1.0) * query.scatter_pdf) / (query.pdf + 0.00001);
                //}
                //  result.w = 1.0;
            }
        }
        else
        {
            return false;
        }

        vec3 dir_to_cam = (-(cam_rec.point - light_material.point));

        //  float deddlta = ubo.fov / 2.0;
        // float vt = 1 -tan(((M_PI / 180.f) * (ubo.fov)) / 2.f);

        // if(!hit_camera && (dot(dir_to_cam, r.direction)) > 0.99 && (dot(dir_to_cam, -cam.to)) > 0.99)
        // {
        //     hit_camera = true;
        // }
        //      float dist = (length(dir_to_cam));
        if (hit_light)
        {
            // POTENTIAL ISSUES:
            // - direction
            // - checking if it really hit the camera (we treat the camera as a point with 180 fov which is false)
            // origin = rec.point;

            //  result = vec4(light_rec.point / 4, 1);
            PdfSampleRecord rsample;
            rsample.random_point = material.point;

            rsample.light_normal = normalize(camera_ray.direction);
            MaterialQueryRecord light_query;
            bool hit_cam;
            light_query = material_query_camera(light_material, light_ray, rsample, hit_cam, -1);
            // summed_ior *= query.effective_ior;
            if (!hit_cam)
            {
                return false;
            }

            // cam_material.albedo = light_result.xyz;
            light_query = material_update_attenuation(light_query, light_material);
            // light_query.attenuation = cam_material.albedo;
            //   camera_ray = camera_query.scatter;
            light_result = light_result * (vec4(light_query.attenuation, 1.0) * light_query.scatter_pdf) / (light_query.pdf + 0.00001);
            result = (result * light_result) / (length(dir_to_cam) * length(dir_to_cam));
            //  result.w = 1.0;

            //  result = light_result * result;
            //  result = vec4(length(rec.point - cam.origin) / 100);
            return true;
        }
        depth += 1;
        cam_rec = world_hit(camera_ray, -1, -1);

        if (cam_rec.hitted == false)
        {
            return false;
        }
    }

    return false;
};
bool light_to_camera(inout vec4 result, camera cam, Ray r, uint maxv, out vec3 origin)
{
    HittableRecord rec = world_hit(r, -1, -1);
    if (!rec.hitted)
    {
        return false;
    }
    uint depth = 0;
    float accum = 1.0;
    int transparent_depth = 8;

    float summed_ior = 1;
    while (depth < maxv && transparent_depth > 0)
    {
        MaterialRecord material = material_hit_info(rec, r);
        MaterialQueryRecord query;

        bool hit_camera = false;
        // return vec4(material.,0,0,1);
        if (material.do_scatter)
        {
            PdfSampleRecord rsample;
            rsample.random_point = cam.origin;
            rsample.light_normal = normalize(-cam.to);
            if (material.transparent)
            {

                //     MaterialQueryRecord material_query_camera(MaterialRecord record, Ray r, PdfSampleRecord forced_record, out bool look_cam, float prob)

                query = material_query_camera(material, r, rsample, hit_camera, 1);
                query = material_update_attenuation(query, material);
                depth -= 1;
                transparent_depth -= 1;
                r = query.scatter;
                // result = result * vec4(1,0,0,1);
                // result = result * (vec4(query.attenuation, 1.0) * query.scatter_pdf) / (query.pdf + 0.001);
            }
            else
            {
                query = material_query_camera(material, r, rsample, hit_camera, (depth + 2) == maxv ? 0 : 0.5);
                summed_ior *= query.effective_ior;

                query = material_update_attenuation(query, material);
                //       query.attenuation =  material.albedo;
                r = query.scatter;

                result = result * (vec4(query.attenuation, 1.0) * query.scatter_pdf) / (query.pdf + 0.00001);
                //  result.w = 1.0;
            }
        }
        else
        {
            return false;
        }

        vec3 dir_to_cam = normalize(-(rec.point - cam.origin));

        //  float deddlta = ubo.fov / 2.0;
        // float vt = 1 -tan(((M_PI / 180.f) * (ubo.fov)) / 2.f);

        // if(!hit_camera && (dot(dir_to_cam, r.direction)) > 0.99 && (dot(dir_to_cam, -cam.to)) > 0.99)
        // {
        //     hit_camera = true;
        // }
        float dist = (length(-(rec.point - cam.origin)));
        if (hit_camera && !any_hit(r, dist))
        {
            // POTENTIAL ISSUES:
            // - direction
            // - checking if it really hit the camera (we treat the camera as a point with 180 fov which is false)
            origin = rec.point;
            // result = vec4(length(rec.point - cam.origin) / 100);
            return true;
        }
        depth += 1;
        rec = world_hit(r, rec.mesh_id, rec.vert_id);

        if (rec.hitted == false)
        {
            return false;
        }
    }
    return false;
}
#endif
