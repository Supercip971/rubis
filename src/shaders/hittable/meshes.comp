#ifndef MESHES_COMP
#define MESHES_COMP

#include "hittable/bvh.comp"
#include "hittable/hittable.comp"
#include "hittable/material.comp"
#include "utils/color.comp"
#include "utils/ray.comp"

layout(set = 0, std140, binding = 1) readonly restrict buffer MeshesBufData
{
    vec4 buf_datas[];
};

struct Mesh
{
    uint type;
    uint material_type;
    uint material_data_start;
    uint material_data_end;
    uint mesh_data_start;
    uint mesh_data_end;
    vec4 aabb1;
    vec4 aabb2;
};

layout(set = 0, std140, binding = 2) readonly buffer MeshesBuf
{
    Mesh meshes[];
};

layout(set = 0, std140, binding = 4) readonly buffer BvhBuf
{
    Bvh bvhs[];
};

layout(set = 0, binding = 5) uniform texture2D textures[];
layout(set = 0, binding = 6) uniform sampler2D skymap;
layout(set = 0, std140, binding = 7) readonly buffer Lights
{
    uint lights[];
};

layout(set = 0, binding = 8) uniform sampler tex_sampler;
#define FROM_SIBLING 1
#define FROM_PARENT 2
#define FROM_CHILD 3

// size in vec4
#define VERTEX_SIZE 4

PbrtTexture material_load_tex(int begin, int off)
{
    const int scale = 3;
    PbrtTexture result;
    vec4 first = vec4(buf_datas[begin + off * scale]);
    vec4 second = vec4(buf_datas[begin + off * scale + 1]);
    vec4 third = vec4(buf_datas[begin + off * scale + 2]);
    result.id = int(first.x);
    result.tid = int(first.y);
    result.factor = second;
    result.offset = third.xy;
    result.scale = third.zw;
    return result;
}

PbrtTexture material_load_tex_d(vec4 a, vec4 b, vec4 c)
{
    const int scale = 3;
    PbrtTexture result;
    result.id = int(a.x);
    result.tid = int(a.y);
    result.factor = b;
    result.offset = c.xy;
    result.scale = c.zw;
    return result;
}
HittableRecord process_leaf(Ray r, uint raw, uint id, uint vert, float cmin, float cmax)
{
  //  Mesh current_mesh = meshes[id];

    vec3 pa = buf_datas[raw + vert * VERTICES_SIZE + 0 * VERTEX_SIZE].xyz;
    vec3 pb = buf_datas[raw + vert * VERTICES_SIZE + 1 * VERTEX_SIZE].xyz;
    vec3 pc = buf_datas[raw + vert * VERTICES_SIZE + 2 * VERTEX_SIZE].xyz;

    HittableRecord res = hit_triangle(cmin, cmax, r, pa, pb, pc);

    res.mesh_id = int(id);
    res.vert_id = int(vert);

    return res;
}

struct PdfSampleRecord
{
    vec3 random_point;
    float area;
    float pdf;
    uint id;
};

PdfSampleRecord sample_triangle(uint id, uint mid)
{
    vec3 pa = buf_datas[id + 0 * VERTEX_SIZE].xyz;
    vec3 pb = buf_datas[id + 1 * VERTEX_SIZE].xyz;
    vec3 pc = buf_datas[id + 2 * VERTEX_SIZE].xyz;

    vec3 ab = pb - pa;
    vec3 ac = pc - pa;

    float u_1 = random();
    float u_2 = random();
    if (u_1 < u_2)
    {
        u_1 = u_1 / 2;
        u_2 = u_2 - u_1;
    }
    else
    {
        u_2 = u_2 / 2;
        u_1 = u_1 - u_2;
    }
    vec3 p = pa + u_1 * ab + u_2 * ac;

    float area = 0.5 * length(cross(ab, ac));
    if (area < 0.00001)
    {
        area = 0.00001;
    }
    float pdf = 1.0 / area;
    return PdfSampleRecord(p, area, pdf, mid);
}
PdfSampleRecord sample_random(vec3 origin, vec3 n)
{
    int id = clamp(int(random() * float(lights.length())), 0, lights.length() - 1);

    Mesh current_mesh = meshes[lights[nonuniformEXT(id)]];

    const int triangle_size = 3 * VERTEX_SIZE;
    int offset = int(random() * float((current_mesh.mesh_data_end - current_mesh.mesh_data_start) / triangle_size));
    offset = int(clamp(offset, 0, (current_mesh.mesh_data_end - current_mesh.mesh_data_start) / triangle_size - 1));
    offset = offset * triangle_size;
    uint vid = current_mesh.mesh_data_start + uint(offset);

    return sample_triangle(vid, lights[nonuniformEXT(id)]);
}

HittableRecord traverse_bvh_stack(Ray r, float cmin_f, float cmax_f);

bool aabb_hit_impl(Ray r, vec3 min_v, vec3 max_v , float t_min, float t_max)
{

    const vec3 invd = (r.inv_direction);
    //
    vec3 t0 = ((min_v- r.origin) * invd);
    vec3 t1 = ((max_v - r.origin) * invd);
    if (invd.x < 0.0f)
    {
        // if(dir.x < 0)
        // swap(t0.x, t1.x);
        float _temp = t0.x;
        t0.x = t1.x;
        t1.x = _temp;
    }
    if (invd.y < 0.0f)
    {
        //  if(dir.y < 0)
        // swap(t0.y, t1.y);
        float _temp = t0.y;
        t0.y = t1.y;
        t1.y = _temp;
    }
    if (invd.z < 0.0f)
    {
        // if(dir.z < 0)
        // swap(t0.z, t1.z);
        float _temp = t0.z;
        t0.z = t1.z;
        t1.z = _temp;
    }
    t_min = max(t0.y, t_min);
    t_min = max(t0.z, t_min);
    t_min = max(t0.x, t_min);

    t_max = min(t1.x, t_max);
    t_max = min(t1.z, t_max);
    t_max = min(t1.y, t_max);
    if (t_max < t_min)
    {
        return false;
    }

    return true;
}
bool aabb_hit(Ray r, Bvh cur, float t_min, float t_max)
{

    const vec3 invd = (r.inv_direction);
    //
    vec3 t0 = ((cur.aabb_min.xyz - r.origin) * invd);
    vec3 t1 = ((cur.aabb_max.xyz - r.origin) * invd);
    if (invd.x < 0.0f)
    {
        // if(dir.x < 0)
        // swap(t0.x, t1.x);
        float _temp = t0.x;
        t0.x = t1.x;
        t1.x = _temp;
    }
    if (invd.y < 0.0f)
    {
        //  if(dir.y < 0)
        // swap(t0.y, t1.y);
        float _temp = t0.y;
        t0.y = t1.y;
        t1.y = _temp;
    }
    if (invd.z < 0.0f)
    {
        // if(dir.z < 0)
        // swap(t0.z, t1.z);
        float _temp = t0.z;
        t0.z = t1.z;
        t1.z = _temp;
    }
    t_min = max(t0.y, t_min);
    t_min = max(t0.z, t_min);
    t_min = max(t0.x, t_min);

    t_max = min(t1.x, t_max);
    t_max = min(t1.z, t_max);
    t_max = min(t1.y, t_max);
    if (t_max < t_min)
    {
        return false;
    }

    return true;
}
bool aabb_hit2(Ray r, Bvh cur, float t_min, float t_max)
{

    vec3 inv_dir = vec3(1) / r.direction;
    vec3 t0 = ((cur.aabb_min.xyz - r.origin) / r.direction);
    vec3 t1 = ((cur.aabb_max.xyz - r.origin) / r.direction);
    vec3 tmax = max(t0, t1);
    vec3 tmin = min(t0, t1);

    return vec3_min_comp(tmax) >= vec3_max_comp(tmin);
}

#define STACK_SIZE 64

struct CacheRecord
{
    HittableRecord result;
    Ray ray;
};
int cache_off = 0;
int cache_len = 0;
CacheRecord cache[3];

uint stack[STACK_SIZE];
HittableRecord traverse_bvh_stack(Ray r, float cmin_f, float cmax_f)
{

    HittableRecord res;
    res.hitted = false;
    float cmin = cmin_f;
    float cmax = cmax_f;
    
    int i = 0;
    int sp = 0;
    int depth = 0;
    stack[sp] = 0;
    sp++;
    const bool direction = true;
    int ccount = 0;

    mat4 m = mat4(1);
#ifdef SHOW_DEPTH
    Bvh dcur = bvhs[stack[0]];

    if (aabb_hit(r, bvhs[0], cmin, cmax))
    {
        depth++;
    }
#endif
    while (sp > 0 && sp < STACK_SIZE)
    {
        sp--; // pop

        Bvh cur = bvhs[nonuniformEXT(stack[sp])];
        if (cur.is_next_a_bvh == 0)
        {

            HittableRecord rec2 = process_leaf(r, cur.lraw, uint(cur.la), uint(cur.lb), cmin, cmax);

#ifdef SHOW_DEPTH
            ccount++;
#endif
            if (rec2.hitted)
            {
                cmax = rec2.t;
                res = rec2;

#ifdef SHOW_DEPTH
                depth = max(depth, sp + 8);
#endif
            }
            if (cur.ra != 0)
            {
                rec2 = process_leaf(r, cur.rraw, uint(cur.ra),uint( cur.rb), cmin, cmax);
#ifdef SHOW_DEPTH

                ccount++;
#endif

                if (rec2.hitted)
                {
                    cmax = rec2.t;
                    res = rec2;

#ifdef SHOW_DEPTH
                    depth = max(depth, sp + 8);
#endif
                }
            }
            /*
            HittableRecord rec2 = process_leaf(r, cur.la, cur.r, cmin, cmax);
            if (rec2.hitted)
            {
                cmax = rec2.t;
                res = rec2;
            }*/
        }
        else
        {
            Bvh lb = bvhs[nonuniformEXT(cur.la)];
            Bvh rb = bvhs[nonuniformEXT(cur.ra)];
            if (aabb_hit(r, lb, cmin, cmax))
            {

                stack[sp] = uint(cur.la);
                //   cmax_stack[sp] = cmax;
                sp++;

#ifdef SHOW_DEPTH
                depth = max(depth, sp + 1);
#endif
            }
            if (aabb_hit(r, rb, cmin, cmax))
            {

                stack[sp] = uint(cur.ra);
                //   cmax_stack[sp] = cmax;

                sp++;
#ifdef SHOW_DEPTH
                depth = max(depth, sp + 1);
#endif
            }
        }
    }

#ifdef SHOW_DEPTH
    res.depth = depth;
#endif
    return res;
}

// # Temporary way of getting the normal vector from a reflection and a input vector
vec3 inverse_reflection(vec3 dir, vec3 reflected)
{
    return (reflected - 2.0 * dot(reflected, -dir) * (-dir));
}

vec3 material_tex_query(PbrtTexture tex, vec2 uv)
{
    mat3 translation = mat3(1, 0, 0, 0, 1, 0, tex.offset.x + 1, tex.offset.y + 1, 1);

    mat3 scale = mat3(tex.scale.x * 1, 0, 0, 0, tex.scale.y * 1, 0, 0, 0, 1);

    mat3 matrix = translation * scale;
    vec2 uvTransformed = (matrix * vec3(uv.xy, 1)).xy;

    vec3 result = texture(sampler2D(textures[nonuniformEXT(tex.id)], tex_sampler), uvTransformed).rgb;
    return result;
}

vec4 material_tex_query_w(PbrtTexture tex, vec2 uv)
{
    mat3 translation = mat3(1, 0, 0, 0, 1, 0, tex.offset.x + 1, tex.offset.y + 1, 1);

    mat3 scale = mat3(tex.scale.x, 0, 0, 0, tex.scale.y, 0, 0, 0, 1);

    mat3 matrix = translation * scale;
    vec2 uvTransformed = (matrix * vec3(uv.xy, 1)).xy;
    // uvTransformed = vec2(0.5, 0.5);
    // if(tex.id == 11)
    //{
    //    return vec4(uv.x,uv.y,0,1);
    //}

    vec4 result = texture(sampler2D(textures[nonuniformEXT(tex.id)], tex_sampler), uvTransformed);
    //  result.w = 1.0;
    return result;
}
vec3 cosine_sample_hemisphere(float r1, float r2)
{

    float phi = 2.0 * M_PI * r1;

    float rt_r2 = sqrt(r2);
    float x = cos(phi) * rt_r2;
    float y = sin(phi) * rt_r2;

    float z = sqrt(max(0.0, 1.0 - x * x - y * y));
    return normalize(vec3(x, y, z));
}

vec3 importance_sample(float r, float r1, float r2)
{
    float phi = 2.0 * M_PI * r1;

    float rt_r2 = sqrt(max(r2, 0.0));
    float z = sqrt(max(1 - r2, 0.0));
    float x = r * cos(phi) * rt_r2;
    float y = r * sin(phi) * rt_r2;

    return normalize(vec3(x, y, z));
}

PdfSampleRecord sample_point(vec3 N, vec3 point)
{

    bool continue_v = true;
    int maxv = 0;
    PdfSampleRecord pdf_sample = sample_random(point, N);
    vec3 dir = -(point - pdf_sample.random_point);

    if (dot(dir, N) <= 0.0001)
    {
        float pdf = -1;

        pdf_sample.pdf = pdf;

        return pdf_sample;
    }
    else
    {
        vec3 cdir = normalize(dir);
        Ray new_ray = Ray(point, cdir, 1 / cdir);
        float dist = length(dir);

        dir = cdir;
        float pdf = (dist * dist) / (max(dot(dir, N), 0.00001) * abs(pdf_sample.area));

        pdf_sample.pdf = pdf;

        return pdf_sample;
        //      mvr = dumb_brdf(r, record, roughness_value, metal_value, result.attenuation, dir, N);
        //            }
    }

}

MaterialRecord material_hit_info(HittableRecord record, Ray r)
{
    Mesh current_mesh = meshes[record.mesh_id];

    MaterialRecord result;
    result.emitted = vec3(0, 0, 0);
    const int start_v = int(current_mesh.material_data_start);
    PbrtTexture albedo_T = material_load_tex(start_v, 0);
    PbrtTexture normal_T = material_load_tex(start_v, 1);
    PbrtTexture metallic_roughness_T = material_load_tex(start_v, 2);
    PbrtTexture emit_T = material_load_tex(start_v, 3);
    PbrtTexture transmission_T = material_load_tex(start_v, 4);

    int base = int(albedo_T.id);
    int base_tid = int(albedo_T.tid);

    int metal = int(metallic_roughness_T.id);
    int metal_tid = int(metallic_roughness_T.tid);

    int normal = int(normal_T.id);
    int normal_tid = int(normal_T.tid);

    int emitid = int(emit_T.id);

    vec3 emit = emit_T.factor.xyz;

    if (emitid >= 0)
    {
        emit *= material_tex_query(emit_T, record.uv).xyz;
    }

    float transmission = transmission_T.factor.x;

    int transmission_id = int(transmission_T.id);

    int transmission_tid = int(transmission_T.tid);

    if (transmission_id >= 0)
    {
        vec2 fuv = record.uv;
        if (transmission_tid == 1)
        {
            fuv = record.uv2;
        }
        transmission *= material_tex_query(transmission_T, record.uv).x;
    }

    result.transmission = transmission;

    // emit = sqrt(emit);

    result.do_scatter = true;
    if (length(emit) > 0.9)
    {
        result.do_scatter = false;
    }

    vec3 fact = albedo_T.factor.xyz;
    float alpha = albedo_T.factor.w;
    if (base < 0)
    {
        result.albedo = fact;
    }
    else
    {
        vec2 fuv = record.uv;
        if (base_tid == 1)
        {
            fuv = record.uv2;
        }
        vec4 col = material_tex_query_w(albedo_T, fuv);
        result.albedo = (col.rgb) * fact;

        alpha *= col.a;
    }

    vec3 T = ((record.tangent));
    vec3 N = ((record.normal));
    vec3 B = (record.bittangent);

    if (dot(N, r.direction) > 0)
    {
        N = -N;
    }
    vec3 og_normal = record.normal;

    result.oN = og_normal;
    vec3 unit_direction = vec_unit(r.direction);

    if (normal >= 0)
    {
        vec3 normalv = vec3(1);
        vec2 fuv = record.uv;
        if (normal_tid == 1)
        {
            fuv = record.uv2;
        }
        normalv = (material_tex_query(normal_T, fuv).rgb) * 2.0 - vec3(1.0);

        normalv = (normalize(normalv) * vec3(normal_T.factor.xy, 1.0));

        record.normal = normalize((normalv.x) * T + (normalv.y) * B + (normalv.z) * N);
    }

    // recreate a coordinate system

    // https://www.pbr-book.org/3ed-2018/Geometry_and_Transformations/Vectors#CoordinateSystemfromaVector
    N = record.normal;
    if (abs(N.x) > abs(N.y))
    {
        T = normalize(vec3(-N.z, 0, N.x) * inversesqrt(max(N.x * N.x + N.z * N.z, 0.0001)));
    }
    else
    {
        T = normalize(vec3(0, N.z, -N.y) * inversesqrt(max(N.y * N.y + N.z * N.z, 0.0001)));
    }
    B = normalize(cross(N, T));

    result.N = N;
    result.T = T;
    result.B = B;

// debug
#if 0
    if (true)
    {
        result.emitted = vec3(albedo_T.id, metallic_roughness_T.id, emit_T.id) / 11.0; 


        if(albedo_T.id > 11 || metallic_roughness_T.id > 11 || emit_T.id > 11)
        {
            result.emitted = vec3(0, 0, 0);

        }
        result.do_scatter = false;
        return result;
    }
#endif

    vec3 metal_roughness = vec3(1, 1, 1);
    if (metal >= 0)
    {
        vec2 fuv = record.uv;
        if (metal_tid == 1)
        {
            fuv = record.uv2;
        }
        metal_roughness = material_tex_query(metallic_roughness_T, fuv);
    }

    metal_roughness *= metallic_roughness_T.factor.xyz;

    result.emitted = emit;

    const float idx = 1.5;

    float refract_ratio = 1.0 / idx;

    result.ior = refract_ratio;

    if (dot(og_normal, N) < 0)
    {
        refract_ratio = idx;
        result.ior = refract_ratio;
    }

    // y = roughtness
    // z = metalness

    float roughness_value = clamp(metal_roughness.y, 0.0001, 1);
    float metal_value = clamp(metal_roughness.z, 0, 1);

    result.roughness = roughness_value;
    result.metallic = metal_value;

    float cos_theta = min((dot(-unit_direction, N)), 1.0);
    float sin_theta = sqrt(max(1.0 - cos_theta * cos_theta, 0.0));

    result.is_specular = (reflectance(cos_theta, result.ior) > random()); // specular
    result.incident = r.direction;

    result.point = record.point;

    result.transparent = (alpha < random()) ? true : false;
    result.t = record.t;
    if (result.transparent)
    {
        result.is_specular = true; // consider all transparent as specular
    }

    transmission *= (1 - result.metallic);

    result.transmission = transmission;
    if (!result.transparent && !result.is_specular)
    {
        result.is_specular = false;
        result.is_transmissive = (transmission > random());
    }
    else
    {
        result.is_transmissive = false;
    }
    if (random() < (result.metallic) * 0.5 && !result.is_transmissive)
    {
        result.is_specular = true;
    }
    // result.is_specular = false;
    //    result.is_specular = true;
    //    result.transparent = false;
    return result;
}

MaterialQueryRecord material_query(MaterialRecord record, Ray r)
{

    bool is_specular = false;
    //
    vec3 H = record.N;
    vec3 dir = vec3(0);
    vec3 unit_direction = normalize(r.direction);

    float r1 = random();
    float r2 = random();
    if (record.transparent)
    {
        MaterialQueryRecord result;
        result.scatter.origin = record.point;
        result.scatter.direction = unit_direction;
        result.scatter.inv_direction = 1 / (unit_direction);

        result.is_specular = true;
        result.pdf = 1;

        result.scatter_pdf = 1;
        result.H = result.scatter.direction;
        return result;
    }
    if (record.is_specular) // specular
    {
        is_specular = true;
        // https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf

        vec3 np = record.N;

        H = importance_sample(record.roughness, r1, r2);

        H = normalize(H.x * record.T + H.y * record.B + H.z * np);

        if (dot(H, np) < 0)
        {
            H = -H;
        }
        dir = (reflect(unit_direction, H));
    }
    else if (record.is_transmissive)
    {
        vec3 np = unit_direction;

        H = importance_sample(record.roughness, r1, r2);

        H = normalize(H.x * record.T + H.y * record.B + H.z * record.N); // surface normal
        if (dot(H, record.N) < 0)
        {
            H = -H;
        }

        vec3 diff = H - record.N;

        dir = normalize(unit_direction + diff);

        // dir = refract(unit_direction, record.N, record.ior);
        // dir = unit_direction + diff;
        //  if(dot(dir, record.N) > 0)
        //  {
        //      dir = -dir;
        //  }
        // if (dot(H, np) < 0)
        //{
        //    H = -H;
        //}
        // dir = (reflect(unit_direction, H));
    }
    else
    {

        // dir = reflect(unit_direction, record.N);
        dir = cosine_sample_hemisphere(r1, r2);
        dir = normalize(dir.x * record.T + dir.y * record.B + dir.z * record.N);
        H = normalize(dir + unit_direction);
    }
    // dir = record.N;
    dir = normalize(dir);
    MaterialQueryRecord result;
    result.scatter.origin = record.point;
    result.scatter.direction = dir;
    result.scatter.inv_direction = 1 / (dir);

    result.is_specular = is_specular;
    result.pdf = 1;

    result.H = H;

    return result;
}

MaterialQueryRecord material_query_pdf(MaterialRecord record, Ray r, float prob)
{
    MaterialQueryRecord result;
    vec3 dir;

    if (record.transparent)
    {
        result.scatter.direction = r.direction;
        result.scatter.inv_direction = 1 / r.direction;
        result.scatter.origin = record.point;
        result.pdf = 1;
        result.scatter_pdf = 1;
        result.H = result.scatter.direction;
        return result;
    }
    if (record.do_scatter && !record.is_specular && random() > prob && !record.is_transmissive)
    {

        int maxv = 0;

        PdfSampleRecord pdf_sample = sample_point(record.N, record.point);

        if (pdf_sample.pdf <= 0.0001)
        {

            result = material_query(record, r);
            result.pdf = 1;

            result.scatter_pdf = 1;

            //    result.emitted = vec3(0, 1, 0);
            //    result.do_scatter = false;
            //    return result;
        }
        else
        {

            dir = normalize(-(record.point - pdf_sample.random_point));

            result.scatter.direction = dir;
            result.scatter.origin = record.point;
            result.scatter.inv_direction = 1.0 / dir;
            // result.is_specular = false;
            result.pdf = pdf_sample.pdf;
            result.scatter_pdf = 1;
            //    result.emitted = vec3(1, 0, 0);
            //    result.do_scatter = false;
            //    return result;
        }
    }
    else
    {

        result = material_query(record, r);

        result.pdf = 1;

        result.scatter_pdf = 1;
    }

    return result;
}
MaterialQueryRecord material_update_attenuation(MaterialQueryRecord c, MaterialRecord record)
{

    MaterialQueryRecord query = c;
    MaterialValRecord mvr = dumb_brdf(record.roughness, record.metallic, record.incident, record.albedo, query.scatter.direction, record.N, record.transmission, record.ior);

    if (!query.is_specular && !record.transparent && !record.is_transmissive)
    {
        query.scatter_pdf = mvr.pdf;
    }
    else
    {
        query.scatter_pdf = 1;
        query.pdf = 1;
    }

    query.attenuation = mvr.color;
    // result.pdf = pdf_sample.pdf;
    //    result.emitted = vec3(1, 0, 0);
    //    result.do_scatter = false;
    //    return result;

    return query;
}

HittableRecord world_hit(Ray r, int denya, int denyb)
{

    float cmin = 0.00001f;
    float cmax = 100000.f;

    HittableRecord rec = traverse_bvh_stack(r, cmin, cmax);
    if (rec.hitted)
    {
        Mesh current_mesh = meshes[rec.mesh_id];
        uint start = current_mesh.mesh_data_start + rec.vert_id * VERTICES_SIZE;

        vec3 pa = buf_datas[VERTEX_SIZE * 0 + start].xyz;
        vec3 na = buf_datas[VERTEX_SIZE * 0 + start + 1].xyz;
        vec3 ta = (buf_datas[VERTEX_SIZE * 0 + start + 2].xyz);
        vec2 uv1a = buf_datas[VERTEX_SIZE * 0 + start + 3].xy;
        vec2 uv2a = buf_datas[VERTEX_SIZE * 0 + start + 3].zw;

        vec3 pb = buf_datas[VERTEX_SIZE * 1 + start].xyz;
        vec3 nb = buf_datas[VERTEX_SIZE * 1 + start + 1].xyz;
        vec3 tb = (buf_datas[VERTEX_SIZE * 1 + start + 2].xyz);
        vec2 uv1b = buf_datas[VERTEX_SIZE * 1 + start + 3].xy;
        vec2 uv2b = buf_datas[VERTEX_SIZE * 1 + start + 3].zw;

        vec3 pc = buf_datas[VERTEX_SIZE * 2 + start].xyz;
        vec3 nc = buf_datas[VERTEX_SIZE * 2 + start + 1].xyz;
        vec3 tc = (buf_datas[VERTEX_SIZE * 2 + start + 2].xyz);
        vec2 uv1c = buf_datas[VERTEX_SIZE * 2 + start + 3].xy;
        vec2 uv2c = buf_datas[VERTEX_SIZE * 2 + start + 3].zw;

        float tsign = buf_datas[start + 2].w;
        vec3 edge_1 = pb - pa;
        vec3 edge_2 = pc - pa;
        rec.normal = normalize((na * (1 - rec.uv.x - rec.uv.y) + nb * (rec.uv.x) + nc * (rec.uv.y)));

        vec3 n2 = (normalize(cross(edge_1, edge_2)));

        rec.geometry_normal = n2;

        rec.tangent = normalize((ta * (1 - rec.uv.x - rec.uv.y) + tb * (rec.uv.x) + tc * (rec.uv.y)));

        rec.bittangent = normalize(cross(rec.normal, rec.tangent)) * tsign;

        vec2 final = (uv1a * (1.0 - rec.uv.x - rec.uv.y) + uv1b * (rec.uv.x) + uv1c * (rec.uv.y));
        vec2 final2 = (uv2a * (1.0 - rec.uv.x - rec.uv.y) + uv2b * (rec.uv.x) + uv2c * (rec.uv.y));

        rec.uv = final;
        rec.uv2 = final2;

        rec = update_face_normal(rec, r, rec.normal);
    }

    return rec;
}

float map(float value, float min1, float max1, float min2, float max2)
{
    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

vec3 light_off = vec_unit(vec3(-3.9618, -3.142, -1.3474));
vec4 sky_color(Ray r)
{
    //   return vec4(0);
    return vec4(1);
    return vec4(vec3(0.251, 0.612, 1), 1);
    vec3 unit_direction = vec_unit(r.direction);
    float rad = (0.009285) / 4;
    float ldir = map(clamp(dot(-light_off, unit_direction), 1.0 - rad, 1.0), 1.0 - rad, 1.0, 0, 1);

    return vec4(0, 0, 0, 1);
    return vec4(mix(vec3(0.23, 0.36, 0.41), vec3(0.9922, 0.9843, 0.8275) * (100), ldir), 1);
    float t = acos(unit_direction.y);
    float p = atan(-unit_direction.z, unit_direction.x) + 3.1415;
    float u = p * (1 / (2 * 3.1415));
    float v = t * (1 / 3.1415);

    vec3 rc = texture(skymap, vec2(u, v)).rgb;

    return vec4(srgb_to_linear(rc), 1);
}

vec4 ray_color(Ray r, float x, float y, uint maxv)
{

    int last_hit = -1;
    HittableRecord rec = world_hit(r, -1, -1);
    vec4 result = vec4(1);
    int tdepth = 0;
    int depth = 0;

#ifdef SHOW_DEPTH

    if (rec.depth < 5)
    {
        return vec4(0, 0, float(rec.depth) / 10 + 0.5, 1);
    }
    else if (rec.depth < 32)
    {
        return vec4(float(rec.depth) / 64.0 + 0.5, 0, 0, 1);
    }
    else
    {
        return vec4(0, 1.0, 0, 1);
    }
#endif
    if (!rec.hitted)
    {
        return sky_color(r);
    }
    float accum = 1.0;
    int transparent_depth = 8;
    while (depth < maxv && transparent_depth > 0)
    {
        MaterialRecord material = material_hit_info(rec, r);
        MaterialQueryRecord query;
        if (material.do_scatter)
        {

            if (material.transparent)
            {
                query = material_query_pdf(material, r, 1);
                query = material_update_attenuation(query, material);
                depth -= 1;
                transparent_depth -= 1;
                r = query.scatter;
                // result = result * vec4(1,0,0,1);
                // result = result * (vec4(query.attenuation, 1.0) * query.scatter_pdf) / (query.pdf + 0.001);
            }
            else
            {

                query = material_query_pdf(material, r, (depth + 1) == maxv ? 0 : 0.5);
                query = material_update_attenuation(query, material);
                //     query.attenuation =  material.albedo;
                r = query.scatter;
                result = result * (vec4(query.attenuation, 1.0) * query.scatter_pdf) / (query.pdf + 0.001);
                //  result.w = 1.0;
            }
            //   return vec4((vec3(1) + query.N) / 2.0, 1.0);
            // if(material.is_specular)
            //{
            //    return vec4(0,0,0,1);
            //}
            // else
            //{
            //    return vec4(1,1,1,1);
            //}
            // vec3 test = vec3(1,1,1);
            // vec3 r = test.x * material.T + test.y * material.B + test.z * material.N;
            // return vec4((material.albedo), 1);
            // r.origin = rec.point;
            // r.direction = vec3_random_unit();
            // r.inv_direction = vec3(1.0) / r.direction;
        }
        else
        {
            result = result * (vec4(material.emitted, 1.0));

            return result;
        }

        depth += 1;
        // if(depth == 2)
        //{
        //
        // return vec4(normalize(vec2(float(rec.mesh_id), float(rec.vert_id) / 256)).xy, result.x, 1);
        //}
        rec = world_hit(r, rec.mesh_id, rec.vert_id);

        if (rec.hitted == false)
        {
            //  return vec4(material.albedo * result.rgb, 1.0);
            result = result * sky_color(r);

            return result;
        }
    }
    //    r.direction = -light_off;
    //    rec = world_hit(r, x, y);

    //    if(!rec.hitted)
    //    {
    //        result = result * sky_color(r);
    //        return result;
    //
    //    }

    //   return vec4(1,0,0, 1);
    return vec4(0);
}

/*
vec4 ray_color_direct(Ray r, float x, float y, uint maxv)
{

    int last_hit = -1;
    HittableRecord rec = world_hit(r);
    vec4 result = vec4(1);

    int depth = 0;

#ifdef SHOW_DEPTH
    return vec4(float(rec.depth) / 32, float(rec.depth) / 256, float(rec.depth) / 512, 1);
#endif
    if (!rec.hitted)
    {
        //  return vec4(0, 1, 0, 1);
        return sky_color(r);
    }
    float accum = 1.0;
    MaterialRecord material = material_hit_info(rec, r);

    if (!material.do_scatter)
    {
        result = result * (vec4(material.emitted, 1.0));

        return result;
    }
    result = vec4(0,0,0,1);

    float acc = 0;
    while(depth <= maxv)
    {

        MaterialQueryRecord query = material_query_pdf(material, r, 1.0);
        query = material_update_attenuation(query, material);
        vec4 current = vec4(0);

        if(query.pdf == 0)
        {
            continue;
        }
        current = (vec4(query.attenuation, 1.0) * query.scatter_pdf) / (query.pdf + 0.001);
        Ray light_ray = query.scatter;

        HittableRecord light_record = world_hit(light_ray);
        MaterialRecord material2 = material_hit_info(light_record, light_ray);

        if (!material2.do_scatter)
        {
            result += current * (vec4(material2.emitted, 1.0));

            acc += 1;
        }
        depth += 1;

    }

    if(acc == 0)
    {
        return vec4(0,0,0,1);
    }
    result /= float(acc);
    //    r.direction = -light_off;
    //    rec = world_hit(r, x, y);

    //    if(!rec.hitted)
    //    {
    //        result = result * sky_color(r);
    //        return result;
    //
    //    }
    return result;
}
#endif
*/
#endif
