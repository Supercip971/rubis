#ifndef MESHES_COMP
#define MESHES_COMP

#include "hittable/bvh.comp"
#include "hittable/hittable.comp"
#include "hittable/material.comp"
#include "utils/color.comp"
#include "utils/ray.comp"

layout(binding = 4, set = 0) uniform accelerationStructureEXT TLAS;
layout(set = 0, std140, binding = 1) readonly restrict buffer MeshesBufData
{
    vec4 buf_datas[];
};

struct Mesh
{
    uint type;
    uint material_type;
    uint material_data_start;
    uint material_data_end;
    uint mesh_data_start;
    uint mesh_data_end;
    vec4 aabb1;
    vec4 aabb2;
};

layout(set = 0, std140, binding = 2) readonly buffer MeshesBuf
{
    Mesh meshes[];
};

layout(set = 0, binding = 5) uniform texture2D textures[];
layout(set = 0, binding = 6) uniform sampler2D skymap;
layout(set = 0, std140, binding = 7) readonly buffer Lights
{
    uint lights[];
};

layout(set = 0, binding = 8) uniform sampler tex_sampler;
#define FROM_SIBLING 1
#define FROM_PARENT 2
#define FROM_CHILD 3

// size in vec4
#define VERTEX_SIZE 4

PbrtTexture material_load_tex(int begin, int off)
{
    const int scale = 3;
    PbrtTexture result;
    vec4 first = vec4(buf_datas[begin + off * scale]);
    vec4 second = vec4(buf_datas[begin + off * scale + 1]);
    vec4 third = vec4(buf_datas[begin + off * scale + 2]);
    result.id = int(first.x);
    result.tid = int(first.y);
    result.factor = second;
    result.offset = third.xy;
    result.scale = third.zw;
    return result;
}


HittableRecord process_leaf(Ray r, uint raw, uint id, uint vert, float cmin, float cmax)
{
    //  Mesh current_mesh = meshes[id];

    vec3 pa = buf_datas[raw + vert * VERTICES_SIZE + 0 * VERTEX_SIZE].xyz;
    vec3 pb = buf_datas[raw + vert * VERTICES_SIZE + 1 * VERTEX_SIZE].xyz;
    vec3 pc = buf_datas[raw + vert * VERTICES_SIZE + 2 * VERTEX_SIZE].xyz;

    HittableRecord res = hit_triangle(cmin, cmax, r, pa, pb, pc);

    res.mesh_id = int(id);
    res.vert_id = int(vert);

    return res;
}

struct PdfSampleRecord
{
    vec3 random_point;
    float area;
    float pdf;
    uint id;
};

PdfSampleRecord sample_triangle(uint id, uint mid)
{
    vec3 pa = buf_datas[id + 0 * VERTEX_SIZE].xyz;
    vec3 pb = buf_datas[id + 1 * VERTEX_SIZE].xyz;
    vec3 pc = buf_datas[id + 2 * VERTEX_SIZE].xyz;

    vec3 ab = pb - pa;
    vec3 ac = pc - pa;

    float u_1 = random();
    float u_2 = random();
    if (u_1 < u_2)
    {
        u_1 = u_1 / 2;
        u_2 = u_2 - u_1;
    }
    else
    {
        u_2 = u_2 / 2;
        u_1 = u_1 - u_2;
    }
    vec3 p = pa + u_1 * ab + u_2 * ac;

    float area = 0.5 * length(cross(ab, ac));
    if (area < 0.00001)
    {
        area = 0.00001;
    }
    float pdf = 1.0 / area;
    return PdfSampleRecord(p, area, pdf, mid);
}
PdfSampleRecord sample_random(vec3 origin, vec3 n)
{
    int id = clamp(int(random() * float(lights.length())), 0, lights.length() - 1);

    Mesh current_mesh = meshes[lights[nonuniformEXT(id)]];

    const int triangle_size = 3 * VERTEX_SIZE;
    int offset = int(random() * float((current_mesh.mesh_data_end - current_mesh.mesh_data_start) / triangle_size));
    offset = int(clamp(offset, 0, (current_mesh.mesh_data_end - current_mesh.mesh_data_start) / triangle_size - 1));
    offset = offset * triangle_size;
    uint vid = current_mesh.mesh_data_start + uint(offset);

    return sample_triangle(vid, lights[nonuniformEXT(id)]);
}

// # Temporary way of getting the normal vector from a reflection and a input vector
vec3 inverse_reflection(vec3 dir, vec3 reflected)
{
    return (reflected - 2.0 * dot(reflected, -dir) * (-dir));
}

vec3 material_tex_query(PbrtTexture tex, vec2 uv)
{
    mat3 translation = mat3(1, 0, 0, 0, 1, 0, tex.offset.x + 1, tex.offset.y + 1, 1);

    mat3 scale = mat3(tex.scale.x * 1, 0, 0, 0, tex.scale.y * 1, 0, 0, 0, 1);

    mat3 matrix = translation * scale;
    vec2 uvTransformed = (matrix * vec3(uv.xy, 1)).xy;

    vec3 result = texture(sampler2D(textures[nonuniformEXT(tex.id)], tex_sampler), uvTransformed).rgb;
    return result;
}

vec4 material_tex_query_w(PbrtTexture tex, vec2 uv)
{
    mat3 translation = mat3(1, 0, 0, 0, 1, 0, tex.offset.x + 1, tex.offset.y + 1, 1);

    mat3 scale = mat3(tex.scale.x, 0, 0, 0, tex.scale.y, 0, 0, 0, 1);

    mat3 matrix = translation * scale;
    vec2 uvTransformed = (matrix * vec3(uv.xy, 1)).xy;
    // uvTransformed = vec2(0.5, 0.5);
    // if(tex.id == 11)
    //{
    //    return vec4(uv.x,uv.y,0,1);
    //}

    vec4 result = texture(sampler2D(textures[nonuniformEXT(tex.id)], tex_sampler), uvTransformed);
    //  result.w = 1.0;
    return result;
}
vec3 cosine_sample_hemisphere(float r1, float r2)
{

    float phi = 2.0 * M_PI * r1;

    float rt_r2 = sqrt(r2);
    float x = cos(phi) * rt_r2;
    float y = sin(phi) * rt_r2;

    float z = sqrt(max(0.0, 1.0 - x * x - y * y));
    return normalize(vec3(x, y, z));
}

vec3 importance_sample(float r, float r1, float r2)
{
    float phi = 2.0 * M_PI * r1;

    float rt_r2 = sqrt(max(r2, 0.0));
    float z = sqrt(max(1 - r2, 0.0));
    float x = r * cos(phi) * rt_r2;
    float y = r * sin(phi) * rt_r2;

    return normalize(vec3(x, y, z));
}

PdfSampleRecord sample_point(vec3 N, vec3 point)
{

    bool continue_v = true;
    int maxv = 0;
    PdfSampleRecord pdf_sample = sample_random(point, N);
    vec3 dir = -(point - pdf_sample.random_point);

    if (dot(dir, N) <= 0.000001)
    {
        float pdf = -1;

        pdf_sample.pdf = pdf;

        return pdf_sample;
    }
    else
    {
        vec3 cdir = normalize(dir);
        Ray new_ray = Ray(point, cdir, 1 / cdir);
        float dist = length(dir);

        dir = cdir;
        float pdf = (dist * dist) / (max(dot(dir, N), 0.00001) * abs(pdf_sample.area));

        pdf_sample.pdf = pdf;

        return pdf_sample;
        //      mvr = dumb_brdf(r, record, roughness_value, metal_value, result.attenuation, dir, N);
        //            }
    }
}

MaterialRecord material_hit_info(HittableRecord record, Ray r)
{
    Mesh current_mesh = meshes[record.mesh_id];

    MaterialRecord result;
    result.emitted = vec3(0, 0, 0);
    const int start_v = int(current_mesh.material_data_start);
    PbrtTexture albedo_T = material_load_tex(start_v, 0);
    PbrtTexture normal_T = material_load_tex(start_v, 1);
    PbrtTexture metallic_roughness_T = material_load_tex(start_v, 2);
    PbrtTexture emit_T = material_load_tex(start_v, 3);
    PbrtTexture transmission_T = material_load_tex(start_v, 4);

    int base = int(albedo_T.id);
    int base_tid = int(albedo_T.tid);

    int metal = int(metallic_roughness_T.id);
    int metal_tid = int(metallic_roughness_T.tid);

    int normal = int(normal_T.id);
    int normal_tid = int(normal_T.tid);

    int emitid = int(emit_T.id);

    vec3 emit = emit_T.factor.xyz;

    if (emitid >= 0)
    {
        emit *= material_tex_query(emit_T, record.uv).xyz;
    }

    float transmission = transmission_T.factor.x;

    int transmission_id = int(transmission_T.id);

    int transmission_tid = int(transmission_T.tid);

    if (transmission_id >= 0)
    {
        vec2 fuv = record.uv;
        if (transmission_tid == 1)
        {
            fuv = record.uv2;
        }
        transmission *= material_tex_query(transmission_T, record.uv).x;
    }

    result.transmission = transmission;

    // emit = sqrt(emit);
//fixme: check point because it looks weirdo
    result.do_scatter = true;
    if (length(emit) > 0.9)
    {
        result.do_scatter = false;
    }

    vec3 fact = albedo_T.factor.xyz;
    float alpha = albedo_T.factor.w;
    if (base < 0)
    {
        result.albedo = fact;
    }
    else
    {
        vec2 fuv = record.uv;
        if (base_tid == 1)
        {
            fuv = record.uv2;
        }
        vec4 col = material_tex_query_w(albedo_T, fuv);
        result.albedo = (col.rgb) * fact;

        alpha *= col.a;
    }

    vec3 T = ((record.tangent));
    vec3 N = ((record.normal));
    vec3 B = (record.bittangent);

    if (dot(N, r.direction) > 0)
    {
        N = -N;
    }
    vec3 og_normal = record.normal;

    result.oN = og_normal;
    vec3 unit_direction = vec_unit(r.direction);

    if (normal >= 0)
    {
        vec3 normalv = vec3(1);
        vec2 fuv = record.uv;
        if (normal_tid == 1)
        {
            fuv = record.uv2;
        }
        normalv = (material_tex_query(normal_T, fuv).rgb) * 2.0 - vec3(1.0);

        normalv = (normalize(normalv) * vec3(normal_T.factor.xy, 1.0));

        record.normal = normalize((normalv.x) * T + (normalv.y) * B + (normalv.z) * N);
    }

    // recreate a coordinate system

    // https://www.pbr-book.org/3ed-2018/Geometry_and_Transformations/Vectors#CoordinateSystemfromaVector
    N = record.normal;
    if (abs(N.x) > abs(N.y))
    {
        T = normalize(vec3(-N.z, 0, N.x) * inversesqrt(max(N.x * N.x + N.z * N.z, 0.0001)));
    }
    else
    {
        T = normalize(vec3(0, N.z, -N.y) * inversesqrt(max(N.y * N.y + N.z * N.z, 0.0001)));
    }
    B = normalize(cross(N, T));

    result.N = N;
    result.T = T;
    result.B = B;

// debug
#if 0
    if (true)
    {
        result.emitted = vec3(albedo_T.id, metallic_roughness_T.id, emit_T.id) / 11.0; 


        if(albedo_T.id > 11 || metallic_roughness_T.id > 11 || emit_T.id > 11)
        {
            result.emitted = vec3(0, 0, 0);

        }
        result.do_scatter = false;
        return result;
    }
#endif

    vec3 metal_roughness = vec3(1, 1, 1);
    if (metal >= 0)
    {
        vec2 fuv = record.uv;
        if (metal_tid == 1)
        {
            fuv = record.uv2;
        }
        metal_roughness = material_tex_query(metallic_roughness_T, fuv);
    }

    metal_roughness *= metallic_roughness_T.factor.xyz;

    result.emitted = emit;

    const float idx = 1.5;

    float refract_ratio = 1.0 / idx;

    result.ior = refract_ratio;

    if (dot(og_normal, N) < 0)
    {
        refract_ratio = idx;
        result.ior = refract_ratio;
    }

    // y = roughtness
    // z = metalness

    float roughness_value = clamp(metal_roughness.y, 0.0001, 1);
    float metal_value = clamp(metal_roughness.z, 0, 1);

    result.roughness = roughness_value;
    result.metallic = metal_value;

    float cos_theta = min((dot(-unit_direction, N)), 1.0);
    float sin_theta = sqrt(max(1.0 - cos_theta * cos_theta, 0.0));

    result.is_specular = (reflectance(cos_theta, result.ior) > random()); // specular
    result.incident = r.direction;

    result.point = record.point;

    result.transparent = (alpha < random()) ? true : false;
    result.t = record.t;
    if (result.transparent)
    {
        result.is_specular = true; // consider all transparent as specular
    }

    transmission *= (1 - result.metallic);

    result.transmission = transmission;
    if (!result.transparent && !result.is_specular)
    {
        result.is_specular = false;
        result.is_transmissive = (transmission > random());
    }
    else
    {
        result.is_transmissive = false;
    }
    if (random() < (result.metallic) * 0.5 && !result.is_transmissive)
    {
        result.is_specular = true;
    }
    // result.is_specular = false;
    //    result.is_specular = true;
    //    result.transparent = false;
    return result;
}

MaterialQueryRecord material_query(MaterialRecord record, Ray r)
{

    bool is_specular = false;
    //
    vec3 H = record.N;
    vec3 dir = vec3(0);
    vec3 unit_direction = normalize(r.direction);

    float r1 = random();
    float r2 = random();
    if (record.transparent)
    {
        MaterialQueryRecord result;
        result.scatter.origin = record.point;
        result.scatter.direction = unit_direction;
        result.scatter.inv_direction = 1 / (unit_direction);

        result.is_specular = true;
        result.pdf = 1;

        result.scatter_pdf = 1;
        result.H = result.scatter.direction;
        return result;
    }
    if (record.is_specular) // specular
    {
        is_specular = true;
        // https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf

        vec3 np = record.N;

        H = importance_sample(record.roughness, r1, r2);

        H = normalize(H.x * record.T + H.y * record.B + H.z * np);

        if (dot(H, np) < 0)
        {
            H = -H;
        }
        dir = (reflect(unit_direction, H));
    }
    else if (record.is_transmissive)
    {
        vec3 np = unit_direction;

        H = importance_sample(record.roughness, r1, r2);

        H = normalize(H.x * record.T + H.y * record.B + H.z * record.N); // surface normal
        if (dot(H, record.N) < 0)
        {
            H = -H;
        }

        vec3 diff = H - record.N;

        dir = normalize(unit_direction + diff);

        // dir = refract(unit_direction, record.N, record.ior);
        // dir = unit_direction + diff;
        //  if(dot(dir, record.N) > 0)
        //  {
        //      dir = -dir;
        //  }
        // if (dot(H, np) < 0)
        //{
        //    H = -H;
        //}
        // dir = (reflect(unit_direction, H));
    }
    else
    {

        // dir = reflect(unit_direction, record.N);
        dir = cosine_sample_hemisphere(r1, r2);
        dir = normalize(dir.x * record.T + dir.y * record.B + dir.z * record.N);
        H = normalize(dir + unit_direction);
    }
    // dir = record.N;
    dir = normalize(dir);
    MaterialQueryRecord result;
    result.scatter.origin = record.point;
    result.scatter.direction = dir;
    result.scatter.inv_direction = 1 / (dir);

    result.is_specular = is_specular;
    result.pdf = 1;
    result.H = H;

    return result;
}

MaterialQueryRecord material_query_pdf(MaterialRecord record, Ray r, float prob)
{
    MaterialQueryRecord result;
    vec3 dir;

    if (record.transparent)
    {
        result.scatter.direction = r.direction;
        result.scatter.inv_direction = 1 / r.direction;
        result.scatter.origin = record.point;
        result.pdf = 1;
        result.scatter_pdf = 1;
        result.H = result.scatter.direction;
        return result;
    }
    if (record.do_scatter && !record.is_specular && random() > prob && !record.is_transmissive)
    {

        int maxv = 0;
        
        PdfSampleRecord pdf_sample = sample_point(record.N, record.point);

        if (pdf_sample.pdf <= 0.0001)
        {

            result = material_query(record, r);
            result.pdf = 1;

            result.scatter_pdf = 1;

            //    result.emitted = vec3(0, 1, 0);
            //    result.do_scatter = false;
            //    return result;
        }
        else
        {

            dir = normalize(-(record.point - pdf_sample.random_point));

            result.scatter.direction = dir;
            result.scatter.origin = record.point;
            result.scatter.inv_direction = 1.0 / dir;
            // result.is_specular = false;
            result.pdf = pdf_sample.pdf;
            result.scatter_pdf = 1;
            //    result.emitted = vec3(1, 0, 0);
            //    result.do_scatter = false;
            //    return result;
        }
    }
    else
    {

        result = material_query(record, r);

        result.pdf = 1;

        result.scatter_pdf = 1;
    }

    return result;
}
MaterialQueryRecord material_update_attenuation(MaterialQueryRecord c, MaterialRecord record)
{

    MaterialQueryRecord query = c;

   MaterialValRecord mvr = dumb_brdf(record.roughness, record.metallic, record.incident, record.albedo, query.scatter.direction, record.N, record.transmission, record.ior, record.front);

    if (!query.is_specular && !record.transparent && !record.is_transmissive)
    {
        query.scatter_pdf = mvr.pdf;
    }
    else
    {
        query.scatter_pdf = 1;
        query.pdf = 1;
    }

    query.attenuation = mvr.color;
    // result.pdf = pdf_sample.pdf;
    //    result.emitted = vec3(1, 0, 0);
    //    result.do_scatter = false;
    //    return result;

    return query;
}

HittableRecord world_hit(Ray r, int denya, int denyb)
{

    float cmin = 0.00001f;
    float cmax = 100000.f;

    HittableRecord rec;
    rec.hitted = false;
    // traverse_bvh_stack(r, cmin, cmax);

    rayQueryEXT rayQuery;
    rayQueryInitializeEXT(rayQuery, TLAS, gl_RayFlagsOpaqueEXT | gl_RayFlagsCullFrontFacingTrianglesEXT, 0xFF, r.origin, cmin, r.direction, cmax);

    // Start traversal: return false if traversal is complete
    while (rayQueryProceedEXT(rayQuery))
    {
    }
    bool front = false;

    // Returns type of committed (true) intersection
    if (rayQueryGetIntersectionTypeEXT(rayQuery, true) != gl_RayQueryCommittedIntersectionNoneEXT)
    {
        rec.hitted = true;
        rec.mesh_id = rayQueryGetIntersectionInstanceCustomIndexEXT(rayQuery, true);
        rec.vert_id = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);
        // rec.point = r.origin + r.direction * rayQueryGetIntersectionTEXT(rayQuery);
        //  rec.normal = rayQueryGetIntersectionInstanceIntersectionNormalEXT(rayQuery, true);

        vec2 barycentrics = rayQueryGetIntersectionBarycentricsEXT(rayQuery, true);
        vec3 barycentrics3 = vec3(1.0 - barycentrics.x - barycentrics.y, barycentrics.x, barycentrics.y);
        front = rayQueryGetIntersectionFrontFaceEXT(rayQuery, true);
        rec.uv = barycentrics.xy;

        //		//const int primitiveId = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);
    }
    if (rec.hitted)
    {
        Mesh current_mesh = meshes[nonuniformEXT(rec.mesh_id)];
        uint start = current_mesh.mesh_data_start + rec.vert_id * VERTICES_SIZE;

        vec3 pa = buf_datas[nonuniformEXT(VERTEX_SIZE * 0 + start)].xyz;
        vec3 na = buf_datas[nonuniformEXT(VERTEX_SIZE * 0 + start + 1)].xyz;
        vec3 ta = (buf_datas[nonuniformEXT(VERTEX_SIZE * 0 + start + 2)].xyz);
        vec2 uv1a = buf_datas[nonuniformEXT(VERTEX_SIZE * 0 + start + 3)].xy;
        vec2 uv2a = buf_datas[nonuniformEXT(VERTEX_SIZE * 0 + start + 3)].zw;

        vec3 pb = buf_datas[nonuniformEXT(VERTEX_SIZE * 1 + start)].xyz;
        vec3 nb = buf_datas[nonuniformEXT(VERTEX_SIZE * 1 + start + 1)].xyz;
        vec3 tb = (buf_datas[nonuniformEXT(VERTEX_SIZE * 1 + start + 2)].xyz);
        vec2 uv1b = buf_datas[nonuniformEXT(VERTEX_SIZE * 1 + start + 3)].xy;
        vec2 uv2b = buf_datas[nonuniformEXT(VERTEX_SIZE * 1 + start + 3)].zw;

        vec3 pc = buf_datas[nonuniformEXT(VERTEX_SIZE * 2 + start)].xyz;
        vec3 nc = buf_datas[nonuniformEXT(VERTEX_SIZE * 2 + start + 1)].xyz;
        vec3 tc = (buf_datas[nonuniformEXT(VERTEX_SIZE * 2 + start + 2)].xyz);
        vec2 uv1c = buf_datas[nonuniformEXT(VERTEX_SIZE * 2 + start + 3)].xy;
        vec2 uv2c = buf_datas[nonuniformEXT(VERTEX_SIZE * 2 + start + 3)].zw;

        float tsign = buf_datas[nonuniformEXT(start + 2)].w;
        vec3 edge_1 = pb - pa;
        vec3 edge_2 = pc - pa;
        rec.normal = normalize((na * (1 - rec.uv.x - rec.uv.y) + nb * (rec.uv.x) + nc * (rec.uv.y)));

        vec3 n2 = (normalize(cross(edge_1, edge_2)));

        rec.geometry_normal = n2;

        rec.tangent = normalize((ta * (1 - rec.uv.x - rec.uv.y) + tb * (rec.uv.x) + tc * (rec.uv.y)));

        rec.bittangent = normalize(cross(rec.normal, rec.tangent)) * tsign;

        rec.point = pa * (1 - rec.uv.x - rec.uv.y) + pb * (rec.uv.x) + pc * (rec.uv.y);
        vec2 final = (uv1a * (1.0 - rec.uv.x - rec.uv.y) + uv1b * (rec.uv.x) + uv1c * (rec.uv.y));
        vec2 final2 = (uv2a * (1.0 - rec.uv.x - rec.uv.y) + uv2b * (rec.uv.x) + uv2c * (rec.uv.y));

        rec.uv = final;
        rec.uv2 = final2;

       // rec = update_face_normal(rec, r, rec.normal);

        rec.front = front;

        if(dot(r.direction, rec.normal) > 0)
        {
            rec.front = false;
            rec.normal = -rec.normal;
        }
    }

    return rec;
}

float map(float value, float min1, float max1, float min2, float max2)
{
    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

vec3 light_off = -vec_unit(vec3(-1.99851,  1.53129, -3.35852 ));
vec4 sky_color(Ray r)
{
  //   return vec4(0);
    //   //return vec4(1);
   //    return vec4(vec3(0.251, 0.612, 1), 1);
    vec3 unit_direction = vec_unit(r.direction);
    float rad = (0.009285) / 40  ;
    float ldir = map(clamp(dot(-light_off, unit_direction), 1.0 - rad, 1.0), 1.0 - rad, 1.0, 0, 1);

    //  return vec4(0, 0, 0, 1);
 // return vec4(mix(vec3(0.23, 0.36, 0.41), vec3(0.9922, 0.9843, 0.8275) * (100), ldir), 1);
   return vec4(mix(vec3(0), vec3(1) * (100), ldir), 1);


    float t = acos(unit_direction.y);
    float p = atan(-unit_direction.z, unit_direction.x) + 3.1415;
    float u = p * (1 / (2 * 3.1415));
    float v = t * (1 / 3.1415);

    vec3 rc = texture(skymap, vec2(u, v)).rgb;

    return vec4(srgb_to_linear(rc), 1);
}

struct ExportRecord
{
    vec3 pos;
    vec3 normal;
    vec3 albedo;
};
vec4 ray_color(Ray r, float x, float y, uint maxv, out ExportRecord export_record)
{

    int last_hit = -1;
    HittableRecord rec = world_hit(r, -1, -1);
    vec4 result = vec4(1);
    int tdepth = 0;
    int depth = 0;

#ifdef SHOW_DEPTH

    if (rec.depth < 5)
    {
        return vec4(0, 0, float(rec.depth) / 10 + 0.5, 1);
    }
    else if (rec.depth < 32)
    {
        return vec4(float(rec.depth) / 64.0 + 0.5, 0, 0, 1);
    }
    else
    {
        return vec4(0, 1.0, 0, 1);
    }
#endif
    if (!rec.hitted)
    {
        return sky_color(r);
    }
    else
    {
        //     return vec4(rec.uv.x, rec.uv.y, 0, 1);
    }
    float accum = 1.0;
    int transparent_depth = 8;
    while (depth < maxv && transparent_depth > 0)
    {
        MaterialRecord material = material_hit_info(rec, r);
        MaterialQueryRecord query;

        if (depth == 0)
        {
            export_record.pos = rec.point;
            export_record.normal = material.N;
            export_record.albedo = material.albedo;
        }

        // return vec4(material.,0,0,1);
        if (material.do_scatter)
        {

            if (material.transparent)
            {
                query = material_query_pdf(material, r, 1);
                query = material_update_attenuation(query, material);
                depth -= 1;
                transparent_depth -= 1;
                r = query.scatter;
                // result = result * vec4(1,0,0,1);
                // result = result * (vec4(query.attenuation, 1.0) * query.scatter_pdf) / (query.pdf + 0.001);
            }
            else
            {

                query = material_query_pdf(material, r, (depth + 2) == maxv ? 0.5 : 0.5);
                query = material_update_attenuation(query, material);
                //       query.attenuation =  material.albedo;
                r = query.scatter;
                result = result * (vec4(query.attenuation, 1.0) * query.scatter_pdf) / (query.pdf + 0.00001);
                //  result.w = 1.0;
            }
        }
        else
        {
            result = result * (vec4(material.emitted, 1.0));

            return result;
        }

        depth += 1;
        rec = world_hit(r, rec.mesh_id, rec.vert_id);

        if (rec.hitted == false)
        {
            //  return vec4(material.albedo * result.rgb, 1.0);
            result = result * sky_color(r);

            return result;
        }
    }
    return vec4(0);
}

#endif
