#ifndef MESHES_COMP
#define MESHES_COMP

#include "hittable/bvh.comp"
#include "hittable/hittable.comp"
#include "hittable/brdf.comp"
#include "hittable/material.comp"


#include "hittable/textures.comp"


#include "utils/color.comp"
#include "utils/ray.comp"
#include "layouts.comp"
#include "hittable/sampling.comp"

#define FROM_SIBLING 1
#define FROM_PARENT 2
#define FROM_CHILD 3

// size in vec4


HittableRecord world_hit(Ray r, int denya, int denyb)
{

    float cmin = 0.00001f;
    float cmax = 100000.f;

    HittableRecord rec;
    rec.hitted = false;
    // traverse_bvh_stack(r, cmin, cmax);

    rayQueryEXT rayQuery;
    rayQueryInitializeEXT(rayQuery, TLAS, gl_RayFlagsOpaqueEXT | gl_RayFlagsCullFrontFacingTrianglesEXT, 0xFF, r.origin, cmin, r.direction, cmax);

    // Start traversal: return false if traversal is complete
    while (rayQueryProceedEXT(rayQuery))
    {
    }
    bool front = false;

    // Returns type of committed (true) intersection
    if (rayQueryGetIntersectionTypeEXT(rayQuery, true) != gl_RayQueryCommittedIntersectionNoneEXT)
    {
        rec.hitted = true;
        rec.mesh_id = rayQueryGetIntersectionInstanceCustomIndexEXT(rayQuery, true);
        rec.vert_id = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);
        // rec.point = r.origin + r.direction * rayQueryGetIntersectionTEXT(rayQuery);
        //  rec.normal = rayQueryGetIntersectionInstanceIntersectionNormalEXT(rayQuery, true);

        vec2 barycentrics = rayQueryGetIntersectionBarycentricsEXT(rayQuery, true);
        vec3 barycentrics3 = vec3(1.0 - barycentrics.x - barycentrics.y, barycentrics.x, barycentrics.y);
        front = rayQueryGetIntersectionFrontFaceEXT(rayQuery, true);
        rec.uv = barycentrics.xy;

        //		//const int primitiveId = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);
    }
    if (rec.hitted)
    {
        Mesh current_mesh = meshes[nonuniformEXT(rec.mesh_id)];
        uint start = current_mesh.mesh_data_start + rec.vert_id * VERTICES_SIZE;

        vec3 pa = buf_datas[nonuniformEXT(VERTEX_SIZE * 0 + start)].xyz;
        vec3 na = buf_datas[nonuniformEXT(VERTEX_SIZE * 0 + start + 1)].xyz;
        vec3 ta = (buf_datas[nonuniformEXT(VERTEX_SIZE * 0 + start + 2)].xyz);
        vec2 uv1a = buf_datas[nonuniformEXT(VERTEX_SIZE * 0 + start + 3)].xy;
        vec2 uv2a = buf_datas[nonuniformEXT(VERTEX_SIZE * 0 + start + 3)].zw;

        vec3 pb = buf_datas[nonuniformEXT(VERTEX_SIZE * 1 + start)].xyz;
        vec3 nb = buf_datas[nonuniformEXT(VERTEX_SIZE * 1 + start + 1)].xyz;
        vec3 tb = (buf_datas[nonuniformEXT(VERTEX_SIZE * 1 + start + 2)].xyz);
        vec2 uv1b = buf_datas[nonuniformEXT(VERTEX_SIZE * 1 + start + 3)].xy;
        vec2 uv2b = buf_datas[nonuniformEXT(VERTEX_SIZE * 1 + start + 3)].zw;

        vec3 pc = buf_datas[nonuniformEXT(VERTEX_SIZE * 2 + start)].xyz;
        vec3 nc = buf_datas[nonuniformEXT(VERTEX_SIZE * 2 + start + 1)].xyz;
        vec3 tc = (buf_datas[nonuniformEXT(VERTEX_SIZE * 2 + start + 2)].xyz);
        vec2 uv1c = buf_datas[nonuniformEXT(VERTEX_SIZE * 2 + start + 3)].xy;
        vec2 uv2c = buf_datas[nonuniformEXT(VERTEX_SIZE * 2 + start + 3)].zw;

        float tsign = buf_datas[nonuniformEXT(start + 2)].w;
        vec3 edge_1 = pb - pa;
        vec3 edge_2 = pc - pa;
        rec.normal = normalize((na * (1 - rec.uv.x - rec.uv.y) + nb * (rec.uv.x) + nc * (rec.uv.y)));

        vec3 n2 = (normalize(cross(edge_1, edge_2)));

        rec.geometry_normal = n2;

        rec.tangent = normalize((ta * (1 - rec.uv.x - rec.uv.y) + tb * (rec.uv.x) + tc * (rec.uv.y)));

        rec.bittangent = normalize(cross(rec.normal, rec.tangent)) * tsign;

        rec.point = pa * (1 - rec.uv.x - rec.uv.y) + pb * (rec.uv.x) + pc * (rec.uv.y);
        vec2 final = (uv1a * (1.0 - rec.uv.x - rec.uv.y) + uv1b * (rec.uv.x) + uv1c * (rec.uv.y));
        vec2 final2 = (uv2a * (1.0 - rec.uv.x - rec.uv.y) + uv2b * (rec.uv.x) + uv2c * (rec.uv.y));

        rec.uv = final;
        rec.uv2 = final2;

       // rec = update_face_normal(rec, r, rec.normal);

        rec.front = front;

        if(dot(r.direction, rec.normal) > 0)
        {
            rec.front = false;
            rec.normal = -rec.normal;
        }
    }

    return rec;
}

float map(float value, float min1, float max1, float min2, float max2)
{
    return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
}

vec3 light_off = -vec_unit(vec3(-1.99851,  1.53129, -3.35852 ));
vec4 sky_color(Ray r)
{
     return vec4(0);
    //   //return vec4(1);
   //    return vec4(vec3(0.251, 0.612, 1), 1);
    vec3 unit_direction = vec_unit(r.direction);
    float rad = (0.009285) / 40  ;
    float ldir = map(clamp(dot(-light_off, unit_direction), 1.0 - rad, 1.0), 1.0 - rad, 1.0, 0, 1);

    //  return vec4(0, 0, 0, 1);
 // return vec4(mix(vec3(0.23, 0.36, 0.41), vec3(0.9922, 0.9843, 0.8275) * (100), ldir), 1);
   return vec4(mix(vec3(0), vec3(1) * (100), ldir), 1);


    float t = acos(unit_direction.y);
    float p = atan(-unit_direction.z, unit_direction.x) + 3.1415;
    float u = p * (1 / (2 * 3.1415));
    float v = t * (1 / 3.1415);

    vec3 rc = texture(skymap, vec2(u, v)).rgb;

    return vec4(srgb_to_linear(rc), 1);
}

struct ExportRecord
{
    vec3 pos;
    vec3 normal;
    vec3 albedo;
};
vec4 ray_color(Ray r, float x, float y, uint maxv, out ExportRecord export_record)
{

    int last_hit = -1;
    HittableRecord rec = world_hit(r, -1, -1);
    vec4 result = vec4(1);
    int tdepth = 0;
    int depth = 0;

#ifdef SHOW_DEPTH

    if (rec.depth < 5)
    {
        return vec4(0, 0, float(rec.depth) / 10 + 0.5, 1);
    }
    else if (rec.depth < 32)
    {
        return vec4(float(rec.depth) / 64.0 + 0.5, 0, 0, 1);
    }
    else
    {
        return vec4(0, 1.0, 0, 1);
    }
#endif
    if (!rec.hitted)
    {
        return sky_color(r);
    }
    else
    {
        //     return vec4(rec.uv.x, rec.uv.y, 0, 1);
    }
    float accum = 1.0;
    int transparent_depth = 8;
    while (depth < maxv && transparent_depth > 0)
    {
        MaterialRecord material = material_hit_info(rec, r);
        MaterialQueryRecord query;

        if (depth == 0)
        {
            export_record.pos = rec.point;
            export_record.normal = material.N;
            export_record.albedo = material.albedo;
        }

        // return vec4(material.,0,0,1);
        if (material.do_scatter)
        {

            if (material.transparent)
            {
                query = material_query_pdf(material, r, 1);
                query = material_update_attenuation(query, material);
                depth -= 1;
                transparent_depth -= 1;
                r = query.scatter;
                // result = result * vec4(1,0,0,1);
                // result = result * (vec4(query.attenuation, 1.0) * query.scatter_pdf) / (query.pdf + 0.001);
            }
            else
            {

                query = material_query_pdf(material, r, (depth + 2) == maxv ? 1 : 0.5);
                query = material_update_attenuation(query, material);
                //       query.attenuation =  material.albedo;
                r = query.scatter;
                result = result * (vec4(query.attenuation, 1.0) * query.scatter_pdf) / (query.pdf + 0.00001);
                //  result.w = 1.0;
            }
        }
        else
        {

            material.emitted = (material.emitted) * abs(dot(material.N, r.direction)) / length(rec.point - r.origin);

            //material.emitted = material.emitted * ;
            result = result * (vec4(material.emitted, 1.0));

            return result;
        }

        depth += 1;
        rec = world_hit(r, rec.mesh_id, rec.vert_id);

        if (rec.hitted == false)
        {
            //  return vec4(material.albedo * result.rgb, 1.0);
            result = result * sky_color(r);

            return result;
        }
    }
    return vec4(0);
}

#endif
