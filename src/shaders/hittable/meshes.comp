#ifndef MESHES_COMP
#define MESHES_COMP

#include "hittable/bvh.comp"
#include "hittable/hittable.comp"
#include "hittable/material.comp"
#include "utils/color.comp"
#include "utils/ray.comp"

// #define SHOW_BVH

layout(std140, binding = 2) readonly buffer MeshesBufData
{
    vec4 buf_datas[];
};

struct Mesh
{
    uint type;
    uint material_type;
    uint material_data_start;
    uint material_data_end;
    uint mesh_data_start;
    uint mesh_data_end;
    vec4 aabb1;
    vec4 aabb2;
};

layout(std140, binding = 3) readonly buffer MeshesBuf
{
    Mesh meshes[];
};

layout(std140, binding = 5) readonly buffer BvhBuf
{
    Bvh bvhs[];
};
layout(binding = 6) uniform sampler2DArray textures;
layout(binding = 7) uniform sampler2D skymap;

#define FROM_SIBLING 1
#define FROM_PARENT 2
#define FROM_CHILD 3

HittableRecord process_leaf(Ray r, int id, int vert, float cmin, float cmax)
{
    Mesh current_mesh = meshes[id];

    vec3 pa = buf_datas[current_mesh.mesh_data_start + vert * VERTICES_SIZE].xyz;
    vec3 pb = buf_datas[current_mesh.mesh_data_start + vert * VERTICES_SIZE + 1].xyz;
    vec3 pc = buf_datas[current_mesh.mesh_data_start + vert * VERTICES_SIZE + 2].xyz;

    HittableRecord res = hit_triangle(cmin, cmax, r, pa, pb, pc);

    res.mesh_id = id;
    res.vert_id = vert;

    return res;
}

bool aabb_hit(Ray r, Bvh cur, float t_min, float t_max)
{
    const vec3 invd = (r.inv_direction);
    vec3 t0 = ((cur.aabb_min.xyz - r.origin) * invd);
    vec3 t1 = ((cur.aabb_max.xyz - r.origin) * invd);
    if (invd.x < 0.0f)
    {
        // if(dir.x < 0)
        // swap(t0.x, t1.x);
        float _temp = t0.x;
        t0.x = t1.x;
        t1.x = _temp;
    }
    if (invd.y < 0.0f)
    {
        //  if(dir.y < 0)
        // swap(t0.y, t1.y);
        float _temp = t0.y;
        t0.y = t1.y;
        t1.y = _temp;
    }
    if (invd.z < 0.0f)
    {
        // if(dir.z < 0)
        // swap(t0.z, t1.z);
        float _temp = t0.z;
        t0.z = t1.z;
        t1.z = _temp;
    }
    t_min = max(t0.y, t_min);
    t_min = max(t0.z, t_min);
    t_min = max(t0.x, t_min);

    t_max = min(t1.x, t_max);
    t_max = min(t1.z, t_max);
    t_max = min(t1.y, t_max);
    if (t_max < t_min)
    {
        return false;
    }

    return true;
}
bool aabb_hit2(Ray r, Bvh cur, float t_min, float t_max)
{

    vec3 inv_dir = vec3(1) / r.direction;
    vec3 t0 = ((cur.aabb_min.xyz - r.origin) / r.direction);
    vec3 t1 = ((cur.aabb_max.xyz - r.origin) / r.direction);
    vec3 tmax = max(t0, t1);
    vec3 tmin = min(t0, t1);

    return vec3_min_comp(tmax) >= vec3_max_comp(tmin);
}

#define STACK_SIZE 64

HittableRecord traverse_bvh_stack(Ray r, float cmin_f, float cmax_f)
{
    int stack[STACK_SIZE];

    int current = bvhs[0].la;
    float cmin = cmin_f;
    float cmax = cmax_f;
    int i = 0;
    int sp = 0;
    int depth = 0;
    stack[sp] = 0;
    sp++;
    HittableRecord res;
    res.hitted = false;
    
    
    #ifdef SHOW_DEPTH
    Bvh dcur = bvhs[stack[0]];
   

    if(aabb_hit(r, bvhs[0], cmin, cmax))
    {
        depth++;
    }
    #endif
    while (sp > 0 && sp < STACK_SIZE)
    {
        sp--; // pop

        Bvh cur = bvhs[stack[sp]];
        if (cur.is_next_a_bvh == 0)
        {
            
            HittableRecord rec2 = process_leaf(r, cur.la, cur.lb, cmin, cmax);
            if (rec2.hitted)
            {
                cmax = rec2.t;
                res = rec2;

                #ifdef SHOW_DEPTH 
                depth = max(depth, sp + 4);
                #endif
            }
            if (cur.ra != 0)
            {
                rec2 = process_leaf(r, cur.ra, cur.rb , cmin, cmax);
                if (rec2.hitted)
                {
                    cmax = rec2.t;
                    res = rec2;
 
                    #ifdef SHOW_DEPTH 
                    depth = max(depth, sp + 4);
                    #endif                   
                }
            }
            /*
            HittableRecord rec2 = process_leaf(r, cur.la, cur.r, cmin, cmax);
            if (rec2.hitted)
            {
                cmax = rec2.t;
                res = rec2;
            }*/
        }
        else
        {
            Bvh lb = bvhs[cur.la];
            Bvh rb = bvhs[cur.ra];

            if (aabb_hit(r, lb, cmin, cmax))
            {
                stack[sp] = cur.la;

                sp++;

                #ifdef SHOW_DEPTH 
                depth = max(depth, sp + 2);
                #endif

            }
            if (aabb_hit(r, rb, cmin, cmax))
            {

                stack[sp] = cur.ra;

                sp++;
                #ifdef SHOW_DEPTH 
                depth = max(depth, sp + 2);
                #endif

            }
        }
    }

    #ifdef SHOW_DEPTH 
    res.depth = depth;
    #endif
    return res;
}


//# Temporary way of getting the normal vector from a reflection and a input vector
vec3 inverse_reflection(vec3 dir, vec3 reflected)
{
    return (reflected - 2.0 * dot(reflected, -dir) * (-dir));
}


PbrtTexture material_load_tex(int begin, int off)
{
    const int scale = 3;
    PbrtTexture result;
    result.id = int(buf_datas[begin +off*3].x);
    result.tid = int(buf_datas[begin +off*3].y);
    result.factor = buf_datas[begin +off*3+1];
    result.offset = buf_datas[begin +off*3 + 2].xy;
    result.scale = buf_datas[begin +off*3 + 2].zw;
    return result;
}

vec3 material_tex_query(PbrtTexture tex, vec2 uv)
{
    mat3 translation = mat3(1,0,0, 0,1,0, tex.offset.x, tex.offset.y, 1);

    mat3 scale = mat3(tex.scale.x*1,0,0, 0,tex.scale.y*1,0, 0,0,1);

    mat3 matrix = translation  * scale;
    vec2 uvTransformed = ( matrix * vec3(uv.xy, 1) ).xy;
    vec3 result = texture(textures, vec3(uvTransformed, tex.id)).rgb;
    return result;
}
MaterialRecord material_hit(HittableRecord record, Ray r)
{
    Mesh current_mesh = meshes[record.mesh_id];

    MaterialRecord result;
    result.emitted = vec3(0, 0, 0);
    vec4 first = buf_datas[current_mesh.material_data_start].xyzw;
    vec4 tid = buf_datas[current_mesh.material_data_start+4].xyzw;


    int base = int(first.y);
   int base_tid = int(tid.x);


    int metal = int(first.z);
   int metal_tid = int(tid.z);


    int normal = int(first.x);
   int normal_tid = int(tid.y);


    int emitid = int(first.w);

    vec3 emit = buf_datas[current_mesh.material_data_start + 3].xyz;

    if (emitid >= 0)
    {
        emit *= texture(textures, vec3(record.uv, emitid)).xyz;
        
    }

    result.do_scatter  = true;
    if(length(emit) > 0.9)
    {
        result.do_scatter = false; 
    }

    vec3 fact = buf_datas[current_mesh.material_data_start + 2].xyz;

    float alpha = 1;
    if (base < 0)
    {
        result.attenuation = buf_datas[current_mesh.material_data_start + 1].xyz;
        alpha = buf_datas[current_mesh.material_data_start + 1].w;

    }
    else
    {
        vec2 fuv = record.uv;
        if(base_tid == 1)
        {
            fuv = record.uv2;
        }
        result.attenuation = (texture(textures, vec3(fuv, base)).xyz);

  //     result.attenuation = linear_to_srgb(result.attenuation);
        alpha = 1.0;

        //        alpha = texture(textures, vec3(record.uv, base)).w;
    }

    vec3 T = normalize((record.tangent));
    vec3 N = normalize((record.normal));

    vec3 og_normal = record.normal;
    vec3 B = normalize(record.bittangent);

    vec3 unit_direction = vec_unit(r.direction);
    if (record.front)
    {
        T = -T;
        B = -B;

    }
    if (normal >= 0)
    {

        vec3 normalv = vec3(1);
        vec2 fuv = record.uv;
        if(normal_tid >= 0.5)
        {
            fuv = record.uv2;
        }
        normalv = texture(textures, vec3((fuv), int(normal))).rgb * 2.0 - vec3(1.0);
        normalv = normalize(normalv);

        mat3 TBN = (mat3(T, B, N));

        record.normal = normalize(((normalv * TBN)));
    }

  //  result.emitted = (record.normal + vec3(1)) / 2.0;

  //  result.do_scatter = false;
  //  return result;

    vec3 metal_roughness = vec3(1, 1, 1);
    if (metal >= 0)
    {
vec2 fuv = record.uv;
        if(metal_tid == 1)
        {
            fuv = record.uv2;
        }
        metal_roughness = texture(textures, vec3(fuv, metal)).xyz;
    }



    metal_roughness.z *= fact.x;

    metal_roughness.y *= fact.y;

    vec3 nref = reflect(unit_direction, record.normal);
     vec3 ndir = vec_unit(nref + (vec3_random_unit() * (random())) *  clamp(metal_roughness.y, 0, 1));

     vec3 normalv = vec_unit(inverse_reflection(ndir, unit_direction));


       normalv = record.normal;
   if(dot(normalv, r.direction) > 0)
   {
         normalv = -normalv;
   }

    // metal_roughness.z *= (metal_roughness.z);

   // metal_roughness.y *= (metal_roughness.y);

    result.emitted = emit;

    // y = roughtness
    // z = metalness
    vec3 oattenuation = result.attenuation;

    vec3 dir;
    {
        const float idx = 1.5;

        float refract_ratio = 1.0 / idx;
       // if (!record.front)
       // {
       //     refract_ratio = idx;
       // }


        

     vec3 nnorm = vec_unit(record.normal + (vec3_random_unit() * (random())) *  clamp(metal_roughness.y, 0, 1));
        float cos_theta = min((dot(-unit_direction, nnorm)), 1.0);

        float sin_theta = sqrt(1.0 - cos_theta * cos_theta);




        
        if (((reflectance(cos_theta, refract_ratio) > random())) )
        {
     //       result.emitted= vec3(1);
     //       result.do_scatter = false;
     //       return result;
//https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf

            dir = reflect(unit_direction, record.normal);
            dir = vec_unit(dir + (vec3_random_unit() * (random())) *  clamp(metal_roughness.y, 0, 1));

            result.attenuation = dumb_brdf(r, record, clamp(metal_roughness.y, 0, 1), clamp(metal_roughness.z, 0,1), result.attenuation, dir, normalv) * result.attenuation;
         //   result.attenuation = vec3(1,1,1);
         //   vec3 f0 = mix(vec3(refract_ratio), result.attenuation, metal_roughness.z);
        //    result.attenuation = f0;
   //result.attenuation = vec3(0,0,0);
  //          result.do_scatter = false;
         
        }
        else
        {
     //   result.emitted= vec3(0);
     //   result.do_scatter = false;
     //   return result;

            dir = ndir;
            vec3 fnormal = normalv;
            if (random() > (metal_roughness.z))
            {
                fnormal = random_in_hemisphere(record.normal);


                dir = fnormal;
            }
            dir = vec_unit(dir);
  
            result.attenuation =(dumb_brdf(r, record, clamp(metal_roughness.y, 0, 1), clamp(metal_roughness.z, 0,1), result.attenuation, dir, normalv));
          //  result.attenuation = vec3(0,0,0);
        }


    }



   // result.emitted += result.attenuation;

    dir = vec_unit(dir);
  //  if (dot(dir, og_normal) < 0.0f)
  //  {
  //      result.emitted = vec3(1,0,0);
  //      result.do_scatter = false;
  //      return result;
  //      dir = -dir;
  //  }

   //     result.emitted = vec3(0,0,1);
   //     result.do_scatter = false;
   //     return result;
    result.scatter = Ray(record.point, dir, vec3(1));

  //  result.emitted = result.attenuation;
  //  result.do_scatter = false; 
    if (random() > (alpha))
    {
        result.attenuation = vec3(1,1,1);
        result.emitted = vec3(0);
        result.scatter.direction = vec3(r.direction);
        result.do_scatter = true;
    }
    

    result.scatter.inv_direction = vec3(1) / result.scatter.direction;

  //  result.do_scatter = length(emit) < 1.02;
    return result;
}

HittableRecord world_hit(Ray r, float x, float y)
{

    float cmin = 0.000001f;
    float cmax = 1000000.f;

    HittableRecord rec = traverse_bvh_stack(r, cmin, cmax);
    if (rec.hitted)
    {
        Mesh current_mesh = meshes[rec.mesh_id];
        uint start = current_mesh.mesh_data_start + rec.vert_id * VERTICES_SIZE;

        vec3 pa = buf_datas[start].xyz;
        vec3 pb = buf_datas[start + 1].xyz;
        vec3 pc = buf_datas[start + 2].xyz;
        vec2 uv1a = buf_datas[start + 3].xy;
        vec2 uv1b = vec2(buf_datas[start + 3].z, buf_datas[start + 4].x);
        vec2 uv1c = buf_datas[start + 4].yz;

        vec2 uv2a = buf_datas[start + 5].xy;
        vec2 uv2b = vec2(buf_datas[start + 5].z, buf_datas[start + 6].x);
        vec2 uv2c = buf_datas[start + 6].yz;
 
        vec3 na = buf_datas[start + 7].xyz;
        vec3 nb = buf_datas[start + 8].xyz;
        vec3 nc = buf_datas[start + 9].xyz;
        vec3 ta = buf_datas[start + 10].xyz;
        vec3 tb = buf_datas[start + 11].xyz;
        vec3 tc = buf_datas[start + 12].xyz;

        vec3 edge_1 = pb - pa;
        vec3 edge_2 = pc - pa;

        rec.normal = normalize((na * (1 - rec.uv.x - rec.uv.y) + nb * (rec.uv.x) + nc * (rec.uv.y)));

     //         rec.normal = (normalize(cross(edge_1, edge_2)));
        rec.tangent = normalize((ta * (1 - rec.uv.x - rec.uv.y) + tb * (rec.uv.x) + tc * (rec.uv.y)));
        rec.tangent_sign = buf_datas[start + 10].w;
        vec2 final = (uv1a * (1.0 - rec.uv.x - rec.uv.y) + uv1b * (rec.uv.x) + uv1c * (rec.uv.y));
        rec.uv = final;
        vec2 final2 = (uv2a * (1.0 - rec.uv.x - rec.uv.y) + uv2b * (rec.uv.x) + uv2c * (rec.uv.y));
        rec.uv2 = final;


        rec.bittangent = rec.tangent_sign * cross(rec.normal, rec.tangent);
        rec = update_face_normal(rec, r, rec.normal);
    }

    return rec;
}

vec4 sky_color(Ray r)
{
    vec3 unit_direction = vec_unit(r.direction);
    float t = acos(unit_direction.y);
    float p = atan(-unit_direction.z, unit_direction.x) + 3.1415;
    float u = p * (1 / (2 * 3.1415));
    float v = t * (1 / 3.1415);

    vec3 rc = texture(skymap, vec2(u, v)).rgb;

   // return vec4(1, 0, 0, 1);
    return vec4(srgb_to_linear(rc), 1);
}

vec4 ray_color(Ray r, float x, float y, int maxv)
{

    int last_hit = -1;
    HittableRecord rec = world_hit(r, x, y);
    vec4 result = vec4(1);

    int depth = 0;

    #ifdef SHOW_DEPTH
    return vec4(float(rec.depth) / 32, float(rec.depth) / 256, float(rec.depth) / 512, 1);
    #endif
    if (!rec.hitted)
    {
      //  return vec4(0, 1, 0, 1);
        return sky_color(r);
    }

    while (depth <= maxv)
    {
        MaterialRecord material = material_hit(rec, r);

        if (material.do_scatter)
        {
            r = material.scatter;
            result = result * vec4(material.attenuation, 1.0);
        }
        else
        {
            result = result * (vec4(material.emitted, 1.0));

            return result;
        }

        depth += 1;
       

        rec = world_hit(r, x, y);
      
        if (rec.hitted == false)
        {
            result = result * sky_color(r);

            return result;
        }

    }
//    r.direction = -light_off;
//    rec = world_hit(r, x, y);
      
//    if(!rec.hitted)
//    {
//        result = result * sky_color(r);
//        return result;
//        
//    } 
    return result;

}

#endif