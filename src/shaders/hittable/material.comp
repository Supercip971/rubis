#ifndef MATERIAL_COMP
#define MATERIAL_COMP
#include "hittable/brdf.comp"
#include "hittable/hittable.comp"
#include "hittable/material.comp"
#include "hittable/sampling.comp"
#include "hittable/textures.comp"
#include "layouts.comp"
#include "utils/color.comp"
#include "utils/ray.comp"

MaterialRecord material_hit_info(HittableRecord record, Ray r)
{
    Mesh current_mesh = meshes[record.mesh_id];

    MaterialRecord result;
    result.emitted = vec3(0, 0, 0);
    const int start_v = int(current_mesh.material_data_start);
    PbrtTexture albedo_T = material_load_tex(start_v, 0);
    PbrtTexture normal_T = material_load_tex(start_v, 1);
    PbrtTexture metallic_roughness_T = material_load_tex(start_v, 2);
    PbrtTexture emit_T = material_load_tex(start_v, 3);
    PbrtTexture transmission_T = material_load_tex(start_v, 4);

    int base = int(albedo_T.id);
    int base_tid = int(albedo_T.tid);

    int metal = int(metallic_roughness_T.id);
    int metal_tid = int(metallic_roughness_T.tid);

    int normal = int(normal_T.id);
    int normal_tid = int(normal_T.tid);

    int emitid = int(emit_T.id);

    vec3 emit = emit_T.factor.xyz;

    if (emitid >= 0)
    {
        emit *= material_tex_query(emit_T, record.uv).xyz;
    }

    float transmission = transmission_T.factor.x;

    int transmission_id = int(transmission_T.id);

    int transmission_tid = int(transmission_T.tid);

    if (transmission_id >= 0)
    {
        vec2 fuv = record.uv;
        if (transmission_tid == 1)
        {
            fuv = record.uv2;
        }
        transmission *= material_tex_query(transmission_T, record.uv).x;
    }

    result.transmission = transmission;

    // emit = sqrt(emit);
    // fixme: check point because it looks weirdo
    result.do_scatter = true;
    if (length(emit) > 0.9)
    {
        result.do_scatter = false;
    }

    vec3 fact = albedo_T.factor.xyz;
    float alpha = albedo_T.factor.w;
    if (base < 0)
    {
        result.albedo = fact;
    }
    else
    {
        vec2 fuv = record.uv;
        if (base_tid == 1)
        {
            fuv = record.uv2;
        }
        vec4 col = material_tex_query_rgba(albedo_T, fuv);
        result.albedo = (col.rgb) * fact;

        alpha *= col.a;
    }

    vec3 T = ((record.tangent));
    vec3 N = ((record.normal));
    vec3 B = (record.bittangent);

    if (dot(N, r.direction) > 0)
    {
        N = -N;
    }
    vec3 og_normal = record.normal;

    result.oN = og_normal;
    vec3 unit_direction = vec_unit(r.direction);

    if (normal >= 0)
    {
        vec3 normalv = vec3(1);
        vec2 fuv = record.uv;
        if (normal_tid == 1)
        {
            fuv = record.uv2;
        }
        normalv = (material_tex_query(normal_T, fuv).rgb) * 2.0 - vec3(1.0);

        normalv = (normalize(normalv) * vec3(normal_T.factor.xy, 1.0));

        record.normal = normalize((normalv.x) * T + (normalv.y) * B + (normalv.z) * N);
    }

    // recreate a coordinate system

    // https://www.pbr-book.org/3ed-2018/Geometry_and_Transformations/Vectors#CoordinateSystemfromaVector
    N = record.normal;
    if (abs(N.x) > abs(N.y))
    {
        T = normalize(vec3(-N.z, 0, N.x) * inversesqrt(max(N.x * N.x + N.z * N.z, 0.0001)));
    }
    else
    {
        T = normalize(vec3(0, N.z, -N.y) * inversesqrt(max(N.y * N.y + N.z * N.z, 0.0001)));
    }
    B = normalize(cross(N, T));

    result.N = N;
    result.T = T;
    result.B = B;

// debug
#if 0
    if (true)
    {
        result.emitted = vec3(alpha,0,0) ; 


       //if(albedo_T.id > 11 || metallic_roughness_T.id > 11 || emit_T.id > 11)
       //{
       //    result.emitted = vec3(0, 0, 0);

       //}
        result.do_scatter = false;
        return result;
    }
#endif

    vec3 metal_roughness = vec3(1, 1, 1);
    if (metal >= 0)
    {
        vec2 fuv = record.uv;
        if (metal_tid == 1)
        {
            fuv = record.uv2;
        }
        metal_roughness = material_tex_query(metallic_roughness_T, fuv);
    }

    metal_roughness *= metallic_roughness_T.factor.xyz;

    result.emitted = emit;

    // https://en.wikipedia.org/wiki/Cauchy%27s_equation

    // https://en.wikipedia.org/wiki/Refractive_index#Refractive_index_of_glass

    // const float sel_g = random();
    // const float sel_b = random();
    // const float sel_r = random();

    //  const float selected_wave_length = mix(390, 710, random());

    float selected_wave_length = 0;
    float c = random();
    float cc = random();
    if (c <= 0.33) // {1/3}
    {
        selected_wave_length = mix(620, 770, cc);
    }
    else if (c <= 0.66) // {2/3} * (1/2) = 1/3
    {
        selected_wave_length = mix(495, 570, cc);
    }
    else
    {
        selected_wave_length = mix(450, 495, cc);
    }
    const float transmission_refractive_coeff = 0.01342;

    // result.refraction_wavelength = selected_wave_length;

    // Borosilicate glass BK
    const float idx = 1.8 + transmission_refractive_coeff / (selected_wave_length * selected_wave_length * 0.001 * 0.001);

    float refract_ratio = 1.0 / idx;

    result.ior = refract_ratio;

    result.transparent = (alpha*alpha < random()) ? true : false;

    transmission *= (1 - result.metallic);

    bool transmissive = transmission > random();
    // bool is_trans = !result.transparent && ;
    //

    // y = roughtness
    // z = metalness

    float roughness_value = clamp(metal_roughness.y, 0.0001, 1);
    float metal_value = clamp(metal_roughness.z, 0, 1);

    result.roughness = roughness_value;
    result.metallic = metal_value;

    float cos_theta = ((dot(-unit_direction, N)));

    float sin_theta = sqrt(max(1.0 - cos_theta * cos_theta, 0.0));

    result.is_specular = (diel_fresnel_value(cos_theta, result.ior) > random()); // specular
    result.incident = r.direction;

    result.point = record.point;

    result.t = record.t;
    if (result.transparent)
    {
        result.is_specular = true; // consider all transparent as specular
    }

    result.transmission = transmission;
    if (!result.transparent && !result.is_specular)
    {
        result.is_specular = false;
        result.is_transmissive = transmissive;
        if (!record.front && transmissive)
        {
            refract_ratio = idx;
            result.ior = refract_ratio;
        }
    }
    else
    {
        result.is_transmissive = false;
    }
    if (random() < (result.metallic) * 0.5 && !result.is_transmissive)
    {
        result.is_specular = true;
    }

    if (result.is_transmissive)
    {
        result.albedo = result.albedo * 3 * wavelength_to_color(selected_wave_length);
        //  result.albedo = vec3(1);
    }

    if (false)
    {
        result.emitted = vec3(float(record.front), float(!record.front), 0);

        result.do_scatter = false;
        return result;
    }

    result.front = record.front;
    // result.is_specular = false;
    //    result.is_specular = true;
    //    result.transparent = false;
    return result;
}

MaterialQueryRecord material_query(MaterialRecord record, Ray r)
{

    bool is_specular = false;
    //
    vec3 H = record.N;
    vec3 dir = vec3(0);
    vec3 unit_direction = normalize(r.direction);

    float r1 = random();
    float r2 = random();
    if (record.transparent)
    {
        MaterialQueryRecord result;
        result.scatter.origin = record.point;
        result.scatter.direction = unit_direction;
        result.scatter.inv_direction = 1 / (unit_direction);

        result.is_specular = true;
        result.pdf = 1;

        result.scatter_pdf = 1;
        result.H = result.scatter.direction;
        return result;
    }
    if (record.is_specular) // specular
    {
        is_specular = true;
        // https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf

        vec3 np = record.N;

        H = importance_sample(record.roughness, r1, r2);

        H = normalize(H.x * record.T + H.y * record.B + H.z * np);

        if (dot(H, np) < 0)
        {
            H = -H;
        }
        dir = (reflect(unit_direction, H));
    }
    else if (record.is_transmissive)
    {
        vec3 np = unit_direction;

        H = importance_sample(record.roughness, r1, r2);

        H = normalize(H.x * record.T + H.y * record.B + H.z * record.N); // surface normal

        // vec3 diff = H - record.N;

        //        dir = normalize(unit_direction + diff);

        if (dot(H, -unit_direction) < 0)
        {
            H = -H;
        }
        dir = vec_refract(unit_direction, H, record.ior);
        if (dot(unit_direction, dir) < 0)
        {
            dir = -dir;
        }
        //   dir = unit_direction;

        //   H = normalize(record.N);
        //   dir = unit_direction + diff;

        //    dir = (reflect(unit_direction, H));
    }
    else
    {

        // dir = reflect(unit_direction, record.N);
        dir = cosine_sample_hemisphere(r1, r2);
        dir = normalize(dir.x * record.T + dir.y * record.B + dir.z * record.N);
        H = normalize(dir + unit_direction);
    }
    // dir = record.N;
    dir = normalize(dir);

    if (!record.is_transmissive && !record.transparent)
    {
        if (dot(dir, record.N) < 0)
        {
            dir = -dir;
        }
    }

    MaterialQueryRecord result;
    result.scatter.origin = record.point;
    result.scatter.direction = dir;
    result.scatter.inv_direction = 1 / (dir);

    result.is_specular = is_specular;
    result.pdf = 1;
    result.H = H;

    return result;
}

MaterialQueryRecord material_query_pdf(MaterialRecord record, Ray r, float prob)
{
    MaterialQueryRecord result;
    vec3 dir;

    if (record.transparent)
    {
        result.scatter.direction = r.direction;
        result.scatter.inv_direction = 1 / r.direction;
        result.scatter.origin = record.point;
        result.pdf = 1;
        result.scatter_pdf = 1;
        result.H = result.scatter.direction;
        return result;
    }
    if (record.do_scatter && !record.is_specular && random() > prob && !record.is_transmissive)
    {

        int maxv = 0;

        PdfSampleRecord pdf_sample = sample_point(record.N, record.point);

        if (pdf_sample.pdf <= 0.0001)
        {

            result = material_query(record, r);
            result.pdf = 1;

            result.scatter_pdf = 1;

            //    result.emitted = vec3(0, 1, 0);
            //    result.do_scatter = false;
            //    return result;
        }
        else
        {

            dir = normalize(-(record.point - pdf_sample.random_point));

            result.scatter.direction = dir;
            result.scatter.origin = record.point;
            result.scatter.inv_direction = 1.0 / dir;
            // result.is_specular = false;
            result.pdf = pdf_sample.pdf;
            result.scatter_pdf = 1;
            //    result.emitted = vec3(1, 0, 0);
            //    result.do_scatter = false;
            //    return result;
        }
    }
    else
    {

        result = material_query(record, r);

        result.pdf = 1;

        result.scatter_pdf = 1;
    }

    return result;
}
MaterialQueryRecord material_update_attenuation(MaterialQueryRecord c, MaterialRecord record)
{

    MaterialQueryRecord query = c;

    MaterialValRecord mvr = dumb_brdf(record.roughness, record.metallic, record.incident, record.albedo, query.scatter.direction, record.N, record.transmission, record.ior, record.front);

    if (!query.is_specular && !record.transparent && !record.is_transmissive)
    {
        query.scatter_pdf = mvr.pdf;
    }
    else
    {
        query.scatter_pdf = 1;
        query.pdf = 1;
    }

    query.attenuation = mvr.color;
    // result.pdf = pdf_sample.pdf;
    //    result.emitted = vec3(1, 0, 0);
    //    result.do_scatter = false;
    //    return result;

    return query;
}
#endif