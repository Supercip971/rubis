#ifndef MATERIAL_COMP
#define MATERIAL_COMP

#include "hittable/hittable.comp"
#include "utils/ray.comp"

struct MaterialRecord
{
    bool do_scatter;
    Ray scatter;
    vec3 attenuation;
    vec3 emitted;
    float scatter_factor;

    float pdf;
    float scatter_pdf;
    bool has_light;
    HittableRecord light_record;
};

// BASED on gltf sample implementation
// https://github.com/KhronosGroup/glTF-Sample-Viewer/blob/master/source/Renderer/shaders/brdf.glsl
// using: https://google.github.io/filament/Filament.md.html#materialsystem/specularbrdf/geometricshadowing(specularg) optimizations

// note: this is inaccurate but fast :tm:

struct brdf_impl 
{
    vec3 n;
    vec3 h;
    vec3 l;
    vec3 v;
    float roughness;
    float metallic;
    float a;
};

struct PbrtTexture 
{
    int id;
    int tid; 
    vec4 factor;
    vec2 offset;
    vec2 scale;
};
float heaviside(float x)
{
    return x <= 0.0 ? 0.0 : 1.0;
}

float g1_ggx(brdf_impl s, vec3 c, float k)
{
    float n_dot_c = max(dot(s.n, c), 0.0);
    return n_dot_c / (n_dot_c * (1.0 - k) + k);
}
float g_ggx(brdf_impl s)
{
    float k = ((s.a +1.0 )* (s.a+1.0)) / 8.0 ;
    return g1_ggx(s, s.l, k) * g1_ggx(s, s.v, k);
}


float ga_ggx(brdf_impl s)
{
    float n_dot_l = dot(s.n, s.l);
    float n_dot_v = dot(s.n, s.v);
    float h_dot_l = dot(s.h, s.l);
    float h_dot_v = dot(s.h, s.v);
    float sq_a = s.a*s.a;

    float lu = 2 * abs(n_dot_l) * heaviside(h_dot_l);
    float ru = 2 * abs(n_dot_v) * heaviside(h_dot_v);


    float ld = abs(n_dot_l) + sqrt(sq_a + (1 - sq_a) * (n_dot_l * n_dot_l));
    float rd = abs(n_dot_v) + sqrt(sq_a + (1 - sq_a) * (n_dot_v * n_dot_v));

    return (lu / ld) * (ru / rd);
}
float d_ggx(brdf_impl s)
{
    float n_dot_h = dot(s.n, s.h);


    float up = s.a*s.a;

    float down =  ((n_dot_h * n_dot_h) * (s.a*s.a - 1.0f) + 1.0f);

    return (up / (M_PI * down * down));
}


float v_ggx(brdf_impl s)
{

    float n_dot_l = dot(s.n, s.l);
    float n_dot_v = dot(s.n, s.v);
    float h_dot_l = dot(s.h, s.l);
    float h_dot_v = dot(s.h, s.v);
    float sq_a = s.a*s.a;

    float lu =  heaviside(h_dot_l);
    float ru =  heaviside(h_dot_v);


    float ld = abs(n_dot_l) + sqrt(sq_a + (1.0 - sq_a) * (n_dot_l * n_dot_l));
    float rd = abs(n_dot_v) + sqrt(sq_a + (1.0 - sq_a) * (n_dot_v * n_dot_v));

    return (lu / ld) * (ru / rd);
}

float specular(brdf_impl s)
{
   // float g = g_ggx(s);
    float d = d_ggx(s);
    float v = v_ggx(s);
    return  d * v;
}


vec3 diffuse(vec3 color)
{
    return (1.0 / M_PI) * color;
}


vec3 conductor_fresnell(brdf_impl s, vec3 col, float f0)
{
    float f = f0 + (1 - f0) * pow(1.0 - abs(dot(s.v, s.h)), 5);
    return f * col;
}

/*
vec3 fresnell(float VdH, vec3 f, float bsdf)
{
    return bsdf * (f + (1 - f) * pow(1 - abs(VdH), 5));
}
*/

vec3 fresnel_mix(float ior, vec3 base, vec3 layer, float VdH)
{
    float f0 = ((1 - ior) / (1 + ior));
    f0 = f0 * f0;
    float fr = f0 + (1 - f0) * pow((1 - abs(VdH)), 5);
    return mix(base, layer, fr);
}

float smith_g_1(vec3 h, vec3 s, vec3 so, float alpha)
{

    
    float h_dot_s = clamp((dot(h,s)), 0.000001, 1);
    float h_dot_so = clamp((dot(h,so)), 0.000001, 1);


    float sq_alpha = alpha * alpha;
    return h_dot_so * sqrt(sq_alpha + h_dot_s * h_dot_s * (1 - sq_alpha));

//    float a = h_dot_s / (max(0.00001f,alpha) * sqrt(1 - min(0.9999999f,h_dot_s * h_dot_s)));

    // \dfraf{-1 + \sqrt{1 + \dfrac{1}{a^2}}}{2}
//    return  (-1 + sqrt(1 + (1 / (a*a)))) / 2;

}

vec3 fresnel(vec3 f_0, float f90, float ndotv)
{
    return f_0 + (vec3(f90) - f_0) * (pow(clamp(1.0-ndotv, 0.0, 1.0), 5.0)); 
}

float ggx_smith_lambda(float a)
{
    return (-1 + sqrt(1 + (1 / (a*a)))) / 2;
}
float clamp_01_1(float v)
{
    return clamp(v, 0.00001f, 1);
}

float luminance(vec3 c)
{
    return 0.2126 * c.r + 0.7152 * c.g + 0.0722 * c.b;
}

struct MaterialValRecord
{
    float pdf;
    float scatter_pdf;
    vec3 color;
};

MaterialValRecord dumb_brdf(Ray r, HittableRecord hit, float roughness, float metallic, vec3 base, vec3 next, vec3 mnormal)
{
    MaterialValRecord result;
    roughness = clamp(roughness, 0.0001, 0.9999);
    metallic = clamp(metallic, 0.0001, 0.9999);
    vec3 n = (mnormal);
    vec3 v = (-r.direction);
    vec3 l = (next);

    // l = wI
    // v = wO 

    vec3 wO = v;
    vec3 wI = l;
    vec3 h = normalize(l + v);

    if(dot(n, h) < 0)
    {
        result.color= vec3(0,0,0);
        return result;
    }

    if(h.x == 0 && h.y == 0 && h.z == 0)
    {
        result.color= vec3(0,0,0);
        return result;
    }
   // vec3 r = reflect(-l, n);

    float NdotH = clamp(dot(n, h), 0.001,1);

    float NdotV = clamp_01_1(dot(n, v)) ;
 
    float VdotH = clamp_01_1(dot(v, h)) ;
 
    float NdotL = clamp_01_1(dot(n, l)) ;
    float LdotH = clamp_01_1(dot(l, h));
      

   
    float u = VdotH;

    roughness = max(roughness, 0.01);
    float alpha = roughness * roughness;

    float alpha_sq = float(alpha) * float(alpha);
    float alpha_sq_c = max(0.001f * 0.001f, alpha_sq);


    // D
    float ggx_d_denom = max((alpha_sq_c - 1.0) * (NdotH) * (NdotH) + 1, 0.01);
    

    float ggx_d =  ( alpha_sq_c * NdotH ) / (M_PI *  ggx_d_denom * ggx_d_denom);

  // # G

    float ggx_g = max(0.5 / ( smith_g_1(n, l,v, alpha) + smith_g_1(n, v,l, alpha)), 0.0);
    
    // ## Fresnel 

    vec3 f0 = mix(vec3(0.04), base, metallic);


    vec3 F = fresnel(f0,min(60 * luminance(f0), 1.0),  LdotH); 

   vec3 specular = vec3(clamp(((F * ggx_g * ggx_d )/(NdotV * NdotL * 4)), vec3(0), vec3(1)) * NdotL);

    vec3 diffuse = base * ((1/M_PI));

    vec3 res = (vec3(1) - F) * diffuse + specular;

    if (length(res) > 1)
    {
        res = normalize(res);
    }

    float diffuse_ratio =  0.5 * (1.0 - metallic);
    float specular_ratio = 1.0 - diffuse_ratio;
    
    result.color = res;
    
    result.scatter_pdf = abs(dot(n, l)) ;
    result.pdf = diffuse_ratio * (abs(dot(n, l)) / M_PI) + specular_ratio * (ggx_d / (4 * dot(v, h)));

    

    return result;
}

#endif