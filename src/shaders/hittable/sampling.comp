
#ifndef SAMPLING_COMP
#define SAMPLING_COMP

#include "layouts.comp"
#include "utils/vec.comp"

struct PdfSampleRecord
{
    vec3 random_point;
    float area;
    float pdf;
    uint id;

    vec3 light_normal;
};

PdfSampleRecord sample_triangle(uint id, uint mid)
{
    vec3 pa = buf_datas[id + 0 * VERTEX_SIZE].xyz;
    vec3 pb = buf_datas[id + 1 * VERTEX_SIZE].xyz;
    vec3 pc = buf_datas[id + 2 * VERTEX_SIZE].xyz;

    vec3 ab = pb - pa;
    vec3 ac = pc - pa;

    float u_1 = random();
    float u_2 = random();
    if (u_1 < u_2)
    {
        u_1 = u_1 / 2;
        u_2 = u_2 - u_1;
    }
    else
    {
        u_2 = u_2 / 2;
        u_1 = u_1 - u_2;
    }
    vec3 p = pa + u_1 * ab + u_2 * ac;

    float area = 0.5 * length(cross(ab, ac));
    if (area < 0.00001)
    {
        area = 0.00001;
    }
    float pdf = 1.0 / area;
    return PdfSampleRecord(p, area, pdf, mid, normalize(cross(ab, ac)));
}

vec3 cosine_sample_hemisphere(float r1, float r2)
{

    float phi = 2.0 * M_PI * r1;

    float rt_r2 = sqrt(r2);
    float x = cos(phi) * rt_r2;
    float y = sin(phi) * rt_r2;

    float z = sqrt(max(0.0, 1.0 - x * x - y * y));
    return normalize(vec3(x, y, z));
}

vec3 cosine_sample_hemisphere_n(vec3 n)
{
    float r1 = random();
    float r2 = random();
    float phi = 2.0 * M_PI * r1;

    float rt_r2 = sqrt(r2);
    float x = cos(phi) * rt_r2 * 0.5;
    float y = sin(phi) * rt_r2 * 0.5;

    float z = sqrt(max(0.0, 1.0 - x * x - y * y));

    vec3 v = vec3(x, y, z);
    vec3 t = normalize(cross(n, vec3(0.0, 1.0, 1.0)));
    vec3 b = normalize(cross(n, t));

    return normalize(v.x * t + v.y * b + v.z * n);
}
Ray random_light_ray(out vec4 emission)
{
    int id = clamp(int(random() * float(lights.length())), 0, lights.length() - 1);

    Mesh current_mesh = meshes[lights[nonuniformEXT(id)]];

    const int triangle_size = 3 * VERTEX_SIZE;
    int offset = int(random() * float((current_mesh.mesh_data_end - current_mesh.mesh_data_start) / triangle_size));
    offset = int(clamp(offset, 0, (current_mesh.mesh_data_end - current_mesh.mesh_data_start) / triangle_size - 1));
    offset = offset * triangle_size;
    uint vid = current_mesh.mesh_data_start + uint(offset);

    PdfSampleRecord r = sample_triangle(vid, lights[nonuniformEXT(id)]);

    float r1 = random();
    float r2 = random();
    vec3 dir = cosine_sample_hemisphere_n(r.light_normal);

    // if (dot(dir, -r.light_normal) < 0.0)
    // {
    //     dir = -dir;
    // }
    //
    if (random() < 0.5)
    {
        dir = -dir;
    }
    // dir = -r.light_normal;

    const int start_v = int(current_mesh.material_data_start);
    // TODO: use the texture emission instead of factor
    PbrtTexture emit_T = material_load_tex(start_v, 3);
    emission = vec4(emit_T.factor.xyz, 1);
    Ray ray = Ray(r.random_point, dir, 1 / dir);

    ray.origin = ray.origin + ray.direction * 0.01;
    return ray;
}

PdfSampleRecord sample_random(vec3 origin, vec3 n)
{
    int id = clamp(int(random() * float(lights.length())), 0, lights.length() - 1);

    Mesh current_mesh = meshes[lights[nonuniformEXT(id)]];

    const int triangle_size = 3 * VERTEX_SIZE;
    int offset = int(random() * float((current_mesh.mesh_data_end - current_mesh.mesh_data_start) / triangle_size));
    offset = int(clamp(offset, 0, (current_mesh.mesh_data_end - current_mesh.mesh_data_start) / triangle_size - 1));
    offset = offset * triangle_size;
    uint vid = current_mesh.mesh_data_start + uint(offset);

    return sample_triangle(vid, lights[nonuniformEXT(id)]);
}
vec3 importance_sample(float r, float r1, float r2)
{
    float phi = 2.0 * M_PI * r1;

    float rt_r2 = sqrt(max(r2, 0.0));
    float z = sqrt(max(1 - r2, 0.0));
    float x = r * cos(phi) * rt_r2;
    float y = r * sin(phi) * rt_r2;

    return normalize(vec3(x, y, z));
}

PdfSampleRecord sample_point(vec3 N, vec3 point)
{

    bool continue_v = true;
    int maxv = 0;
    PdfSampleRecord pdf_sample = sample_random(point, N);
    vec3 dir = -(point - pdf_sample.random_point);

    if (dot(dir, N) <= 0.000001)
    {
        float pdf = -1;

        pdf_sample.pdf = pdf;

        return pdf_sample;
    }
    else
    {
        vec3 cdir = normalize(dir);
        Ray new_ray = Ray(point, cdir, 1 / cdir);
        float dist = length(dir);

        dir = cdir;
        float pdf = (dist * dist) / (abs(dot(dir, N)) * abs(pdf_sample.area));

        pdf_sample.pdf = pdf;

        return pdf_sample;
        //      mvr = dumb_brdf(r, record, roughness_value, metal_value, result.attenuation, dir, N);
        //            }
    }
}
#endif